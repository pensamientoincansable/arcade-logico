<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Lógico - 15 Minijuegos Completos</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Variables de estilo retro-gamer */
        :root {
            --neon-blue: #0ff0fc;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --neon-yellow: #ffff00;
            --neon-orange: #ff5500;
            --dark-bg: #0a0a1a;
            --card-bg: rgba(16, 16, 32, 0.85);
            --grid-color: rgba(0, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #ccccff;
            --shadow-glow: 0 0 15px var(--neon-blue);
            --border-radius: 12px;
        }

        /* Reset y estilos base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', 'Segoe UI', monospace;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animaciones de fondo retro-gamer */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            opacity: 0.15;
            background: 
                linear-gradient(90deg, var(--dark-bg) 1px, transparent 1px) 0 0 / 50px 50px,
                linear-gradient(var(--dark-bg) 1px, transparent 1px) 0 0 / 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; }
        }

        /* Efecto de scanlines retro */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 255, 255, 0.03) 50%
            );
            background-size: 100% 4px;
            animation: scanlines 10s linear infinite;
        }

        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        /* Puntos de neón flotantes */
        .neon-dots {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .neon-dot {
            position: absolute;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            background-color: var(--neon-blue);
            box-shadow: 0 0 8px var(--neon-blue);
        }

        /* Encabezado */
        header {
            text-align: center;
            padding: 2rem 1rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .title-container {
            position: relative;
            display: inline-block;
        }

        h1 {
            font-size: 3.5rem;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            text-shadow: 
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue),
                0 0 30px var(--neon-blue);
            animation: pulse 3s infinite alternate;
        }

        @keyframes pulse {
            0% { text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue); }
            100% { text-shadow: 0 0 15px var(--neon-blue), 0 0 30px var(--neon-blue), 0 0 40px var(--neon-blue); }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--neon-green);
            margin-bottom: 1rem;
            letter-spacing: 2px;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .stat {
            background: rgba(0, 255, 255, 0.1);
            padding: 0.8rem 1.5rem;
            border-radius: 10px;
            border: 1px solid var(--neon-blue);
            box-shadow: var(--shadow-glow);
        }

        /* Contenedor principal */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1.5rem 3rem;
        }

        /* Grid de juegos */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        /* Tarjetas de juego */
        .game-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            border: 1px solid transparent;
            transition: all 0.4s ease;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            min-height: 280px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .game-card:hover {
            transform: translateY(-8px);
            border-color: var(--neon-blue);
            box-shadow: 
                0 0 20px var(--neon-blue),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transition: left 0.7s ease;
        }

        .game-card:hover::before {
            left: 100%;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .game-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
            line-height: 1;
        }

        .game-title {
            font-size: 1.6rem;
            color: var(--neon-green);
            margin-bottom: 0.8rem;
            text-align: right;
            flex-grow: 1;
        }

        .game-desc {
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 1.2rem;
            flex-grow: 1;
        }

        .game-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: auto;
        }

        .game-difficulty {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .easy { background: rgba(0, 255, 0, 0.2); color: var(--neon-green); border: 1px solid var(--neon-green); }
        .medium { background: rgba(255, 255, 0, 0.2); color: var(--neon-yellow); border: 1px solid var(--neon-yellow); }
        .hard { background: rgba(255, 0, 0, 0.2); color: #ff5555; border: 1px solid #ff5555; }

        .play-btn {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            color: white;
            border: none;
            padding: 0.8rem 1.8rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .play-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
        }

        /* Modo oscuro/brillante toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--neon-blue);
            z-index: 100;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .theme-toggle:hover {
            transform: rotate(30deg) scale(1.1);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Página de juego (oculta inicialmente) */
        .game-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
            z-index: 1000;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }

        .game-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.7);
            border-bottom: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .game-content {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        .back-btn {
            background: transparent;
            color: var(--neon-blue);
            border: 1px solid var(--neon-blue);
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px var(--neon-blue);
        }

        /* Estilos generales para juegos */
        .game-container {
            background: rgba(16, 16, 32, 0.9);
            border-radius: var(--border-radius);
            padding: 2rem;
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
        }

        .game-title-large {
            font-size: 2.5rem;
            color: var(--neon-green);
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px var(--neon-green);
        }

        .game-instructions {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 2rem;
            text-align: center;
            padding: 0 1rem;
        }

        .game-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .game-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            border-radius: 8px;
            padding: 1rem;
            color: white;
            font-size: 1.2rem;
            width: 200px;
            text-align: center;
        }

        .game-button {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            border: none;
            border-radius: 8px;
            padding: 1rem 2rem;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .game-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .game-feedback {
            text-align: center;
            padding: 1.5rem;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            margin: 1.5rem 0;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stat-box {
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            text-align: center;
            border: 1px solid var(--neon-blue);
            min-width: 150px;
        }

        /* Tableros de juego */
        .game-board {
            display: grid;
            gap: 5px;
            margin: 0 auto;
            justify-content: center;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .cell:hover {
            transform: scale(1.05);
        }

        /* Estilos específicos para cada juego */
        /* Tres en Raya */
        .tic-tac-toe-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            margin: 20px auto;
        }

        .tic-tac-toe-cell {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon-blue);
            font-size: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tic-tac-toe-cell:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Sudoku */
        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 1px;
            margin: 20px auto;
            border: 2px solid var(--neon-blue);
        }

        .sudoku-cell {
            border: 1px solid rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.2);
        }

        .sudoku-cell.fixed {
            color: var(--neon-blue);
            font-weight: bold;
            background: rgba(0, 255, 255, 0.05);
        }

        .sudoku-cell.selected {
            background: rgba(0, 255, 255, 0.2);
        }

        .sudoku-cell.highlighted {
            background: rgba(255, 255, 0, 0.1);
        }

        .sudoku-region-0 { background-color: rgba(0, 255, 255, 0.05); }
        .sudoku-region-1 { background-color: rgba(0, 0, 0, 0.1); }
        .sudoku-region-2 { background-color: rgba(0, 255, 255, 0.05); }
        .sudoku-region-3 { background-color: rgba(0, 0, 0, 0.1); }
        .sudoku-region-4 { background-color: rgba(0, 255, 255, 0.05); }
        .sudoku-region-5 { background-color: rgba(0, 0, 0, 0.1); }
        .sudoku-region-6 { background-color: rgba(0, 255, 255, 0.05); }
        .sudoku-region-7 { background-color: rgba(0, 0, 0, 0.1); }
        .sudoku-region-8 { background-color: rgba(0, 255, 255, 0.05); }

        /* Memorama */
        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            grid-template-rows: repeat(4, 100px);
            gap: 10px;
            margin: 20px auto;
        }

        .memory-card {
            width: 100px;
            height: 100px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card-front, .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .memory-card-front {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            color: white;
        }

        .memory-card-back {
            background: var(--card-bg);
            border: 2px solid var(--neon-green);
            transform: rotateY(180deg);
            color: var(--neon-green);
        }

        .memory-card.matched .memory-card-back {
            border-color: var(--neon-pink);
            background: rgba(255, 0, 255, 0.1);
        }

        /* Torres de Hanoi */
        .hanoi-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            height: 300px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
        }

        .hanoi-tower {
            width: 30%;
            height: 250px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            position: relative;
            cursor: pointer;
        }

        .hanoi-base {
            width: 100%;
            height: 10px;
            background: var(--neon-blue);
            border-radius: 5px;
        }

        .hanoi-pole {
            width: 10px;
            height: 200px;
            background: var(--neon-blue);
            position: absolute;
            bottom: 10px;
            border-radius: 5px;
        }

        .hanoi-disk {
            height: 20px;
            margin: 2px 0;
            border-radius: 10px;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .hanoi-disk.selected {
            transform: translateY(-20px);
            box-shadow: 0 0 10px var(--neon-yellow);
        }

        /* Busca Minas */
        .minesweeper-board {
            display: grid;
            gap: 2px;
            margin: 20px auto;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .minesweeper-cell {
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--neon-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .minesweeper-cell.revealed {
            background: rgba(255, 255, 255, 0.1);
        }

        .minesweeper-cell.mine {
            background: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        .minesweeper-cell.flag {
            background: rgba(255, 255, 0, 0.3);
            color: var(--neon-yellow);
        }

        /* 15 Puzzle */
        .puzzle15-board {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 5px;
            margin: 20px auto;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
        }

        .puzzle15-cell {
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 5px;
        }

        .puzzle15-cell.empty {
            background: transparent;
            cursor: default;
        }

        .puzzle15-cell:hover:not(.empty) {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        /* Ahorcado */
        .hangman-drawing {
            margin: 20px auto;
            width: 300px;
            height: 300px;
            position: relative;
        }

        .hangman-part {
            stroke: var(--neon-blue);
            stroke-width: 4;
            stroke-linecap: round;
            fill: none;
            display: none;
        }

        .hangman-part.visible {
            display: block;
        }

        .hangman-word {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            font-size: 2rem;
            letter-spacing: 10px;
        }

        .hangman-letter {
            width: 40px;
            height: 50px;
            border-bottom: 3px solid var(--neon-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Conecta 4 */
        .connect4-board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 5px;
            margin: 20px auto;
            background: linear-gradient(45deg, #0000ff, #0088ff);
            padding: 10px;
            border-radius: 10px;
        }

        .connect4-cell {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .connect4-cell:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .connect4-cell.red {
            background: radial-gradient(circle at 30% 30%, #ff0000, #880000);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .connect4-cell.yellow {
            background: radial-gradient(circle at 30% 30%, #ffff00, #888800);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Laberinto */
        .maze-container {
            margin: 20px auto;
            position: relative;
        }

        .maze-cell {
            width: 30px;
            height: 30px;
            position: absolute;
            transition: all 0.3s ease;
        }

        .maze-wall {
            background: var(--neon-blue);
        }

        .maze-path {
            background: rgba(0, 0, 0, 0.2);
        }

        .maze-start {
            background: var(--neon-green);
        }

        .maze-end {
            background: var(--neon-pink);
        }

        .maze-player {
            background: var(--neon-yellow);
            border-radius: 50%;
            z-index: 10;
            transform: scale(0.8);
            box-shadow: 0 0 10px var(--neon-yellow);
        }

        /* Criptograma */
        .cryptogram-container {
            margin: 20px auto;
            text-align: center;
        }

        .cryptogram-letter {
            display: inline-block;
            width: 40px;
            height: 50px;
            margin: 5px;
            border-bottom: 2px solid var(--neon-blue);
            font-size: 1.5rem;
            text-align: center;
            line-height: 50px;
            text-transform: uppercase;
        }

        .cryptogram-letter.space {
            border-bottom: none;
            width: 20px;
        }

        .cryptogram-keyboard {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin: 20px 0;
            max-width: 600px;
        }

        .cryptogram-key {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cryptogram-key:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .cryptogram-key.used {
            background: rgba(255, 0, 255, 0.2);
            border-color: var(--neon-pink);
        }

        /* Mastermind */
        .mastermind-board {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px auto;
            max-width: 400px;
        }

        .mastermind-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .mastermind-pegs {
            display: flex;
            gap: 5px;
        }

        .mastermind-peg {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .mastermind-peg:hover {
            transform: scale(1.1);
        }

        .mastermind-feedback {
            display: flex;
            gap: 5px;
            margin-left: 20px;
        }

        .mastermind-feedback-peg {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid var(--neon-blue);
        }

        /* Juego de la Vida */
        .life-board {
            display: grid;
            gap: 1px;
            margin: 20px auto;
            background: rgba(0, 255, 255, 0.1);
        }

        .life-cell {
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .life-cell.alive {
            background: var(--neon-green);
            box-shadow: 0 0 5px var(--neon-green);
        }

        /* Battleship */
        .battleship-container {
            display: flex;
            gap: 50px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .battleship-board {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
            gap: 1px;
        }

        .battleship-cell {
            width: 30px;
            height: 30px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .battleship-cell:hover {
            background: rgba(0, 255, 255, 0.3);
        }

        .battleship-cell.hit {
            background: rgba(255, 0, 0, 0.5);
        }

        .battleship-cell.miss {
            background: rgba(255, 255, 255, 0.3);
        }

        .battleship-cell.ship {
            background: rgba(0, 255, 0, 0.3);
        }

        /* Nonogramas */
        .nonogram-container {
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .nonogram-board {
            display: grid;
            gap: 1px;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
        }

        .nonogram-cell {
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nonogram-cell.filled {
            background: var(--neon-blue);
        }

        .nonogram-cell.crossed {
            background: rgba(255, 0, 255, 0.3);
            position: relative;
        }

        .nonogram-cell.crossed::before,
        .nonogram-cell.crossed::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 2px;
            background: var(--neon-pink);
            top: 50%;
            left: 10%;
        }

        .nonogram-cell.crossed::before {
            transform: rotate(45deg);
        }

        .nonogram-cell.crossed::after {
            transform: rotate(-45deg);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
            }
            
            .stats {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }
            
            .game-container {
                padding: 1rem;
            }
            
            .tic-tac-toe-board {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
            }
            
            .memory-board {
                grid-template-columns: repeat(4, 70px);
                grid-template-rows: repeat(4, 70px);
            }
            
            .memory-card {
                width: 70px;
                height: 70px;
            }
            
            .puzzle15-board {
                grid-template-columns: repeat(4, 60px);
                grid-template-rows: repeat(4, 60px);
            }
            
            .puzzle15-cell {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- Fondo animado -->
    <div id="matrix-bg"></div>
    <div class="scanlines"></div>
    <div class="neon-dots" id="neonDots"></div>

    <!-- Página principal -->
    <div id="mainPage">
        <header>
            <div class="title-container">
                <h1>ARCADE LÓGICO</h1>
                <p class="subtitle">15 MINIJUEGOS COMPLETOS PARA EJERCITAR TU MENTE</p>
            </div>
            
            <div class="stats">
                <div class="stat">
                    <i class="fas fa-brain"></i> 15 Juegos Completos
                </div>
                <div class="stat">
                    <i class="fas fa-gamepad"></i> 100% Funcionales
                </div>
                <div class="stat">
                    <i class="fas fa-code"></i> JavaScript Puro
                </div>
            </div>
        </header>

        <div class="container">
            <div class="games-grid" id="gamesGrid">
                <!-- Los juegos se cargarán aquí dinámicamente -->
            </div>
        </div>

        <footer>
            <p>Desarrollado con <i class="fas fa-heart" style="color:var(--neon-pink)"></i> para mentes curiosas | Estilo Retro-Gamer | Todos los juegos implementados</p>
            <p style="margin-top:0.5rem;font-size:0.8rem;color:var(--neon-blue)">Haz clic en cualquier juego para comenzar la aventura lógica</p>
        </footer>

        <div class="theme-toggle" id="themeToggle">
            <i class="fas fa-palette"></i>
        </div>
    </div>

    <!-- Página de juego (inicialmente oculta) -->
    <div id="gamePage" class="game-page">
        <div class="game-header-bar">
            <button class="back-btn" id="backBtn">
                <i class="fas fa-arrow-left"></i> Volver al Menú
            </button>
            <h2 id="currentGameTitle">Cargando juego...</h2>
            <div style="width: 100px;"></div> <!-- Espaciador -->
        </div>
        
        <div class="game-content" id="gameContent">
            <!-- El contenido del juego se cargará aquí -->
        </div>
    </div>

    <script>
        // Datos de los 15 minijuegos COMPLETOS
        const games = [
            {
                id: 1,
                title: "Adivina el Número",
                description: "Adivina el número secreto entre 1 y 100 usando pistas de mayor o menor. ¡Demuestra tu intuición numérica!",
                difficulty: "easy",
                icon: "fa-bullseye",
                hasGame: true
            },
            {
                id: 2,
                title: "Tres en Raya",
                description: "El clásico juego de estrategia. Alinea tres símbolos en horizontal, vertical o diagonal antes que tu oponente.",
                difficulty: "easy",
                icon: "fa-times",
                hasGame: true
            },
            {
                id: 3,
                title: "Sudoku",
                description: "Completa la cuadrícula 9x9 con números del 1 al 9, sin repetir en filas, columnas o regiones 3x3.",
                difficulty: "hard",
                icon: "fa-th",
                hasGame: true
            },
            {
                id: 4,
                title: "Memorama",
                description: "Encuentra todas las parejas de cartas iguales. ¡Ejercita tu memoria visual en este desafío clásico!",
                difficulty: "medium",
                icon: "fa-brain",
                hasGame: true
            },
            {
                id: 5,
                title: "Torres de Hanoi",
                description: "Mueve todos los discos de una torre a otra, sin colocar discos grandes sobre pequeños. Un clásico de la recursividad.",
                difficulty: "medium",
                icon: "fa-layer-group",
                hasGame: true
            },
            {
                id: 6,
                title: "Busca Minas",
                description: "Encuentra todas las minas sin activar ninguna. Usa los números como pistas para localizar el peligro.",
                difficulty: "medium",
                icon: "fa-bomb",
                hasGame: true
            },
            {
                id: 7,
                title: "15 Puzzle",
                description: "Ordena los números del 1 al 15 deslizando las piezas en el tablero 4x4. ¡Un rompecabezas deslizante!",
                difficulty: "medium",
                icon: "fa-puzzle-piece",
                hasGame: true
            },
            {
                id: 8,
                title: "Ahorcado",
                description: "Adivina la palabra letra por letra antes de que se complete el dibujo del ahorcado. ¡Vocabulario y lógica!",
                difficulty: "easy",
                icon: "fa-user",
                hasGame: true
            },
            {
                id: 9,
                title: "Conecta 4",
                description: "Conecta cuatro fichas en línea horizontal, vertical o diagonal. Estrategia pura para dos jugadores.",
                difficulty: "medium",
                icon: "fa-circle",
                hasGame: true
            },
            {
                id: 10,
                title: "Laberinto",
                description: "Encuentra la salida del laberinto generado aleatoriamente. ¡Navega por el camino más corto!",
                difficulty: "hard",
                icon: "fa-project-diagram",
                hasGame: true
            },
            {
                id: 11,
                title: "Criptograma",
                description: "Descifra el mensaje codificado sustituyendo letras. Un desafío de lógica lingüística.",
                difficulty: "hard",
                icon: "fa-key",
                hasGame: true
            },
            {
                id: 12,
                title: "Mastermind",
                description: "Adivina la combinación secreta de colores usando pistas de posición y color. ¡Pura deducción lógica!",
                difficulty: "medium",
                icon: "fa-user-secret",
                hasGame: true
            },
            {
                id: 13,
                title: "Juego de la Vida",
                description: "Simula el autómata celular de Conway. Observa cómo evolucionan los patrones según reglas simples.",
                difficulty: "medium",
                icon: "fa-seedling",
                hasGame: true
            },
            {
                id: 14,
                title: "Battleship",
                description: "Hunde la flota enemiga antes de que hundan la tuya. Estrategia naval clásica para dos jugadores.",
                difficulty: "medium",
                icon: "fa-ship",
                hasGame: true
            },
            {
                id: 15,
                title: "Nonogramas",
                description: "Resuelve el rompecabezas lógico donde números indican grupos de casillas a rellenar. ¡Crea una imagen!",
                difficulty: "hard",
                icon: "fa-border-style",
                hasGame: true
            }
        ];

        // Estado de la aplicación
        const state = {
            currentGame: null,
            darkMode: true,
            gamesPlayed: 0
        };

        // Inicialización de la página
        document.addEventListener('DOMContentLoaded', function() {
            // Crear puntos de neón animados
            createNeonDots();
            
            // Cargar la cuadrícula de juegos
            loadGamesGrid();
            
            // Configurar event listeners
            document.getElementById('backBtn').addEventListener('click', returnToMain);
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Configurar los juegos con funcionalidad
            setupGameButtons();
        });

        // Crear puntos de neón animados para el fondo
        function createNeonDots() {
            const container = document.getElementById('neonDots');
            const dotCount = 50;
            
            for (let i = 0; i < dotCount; i++) {
                const dot = document.createElement('div');
                dot.className = 'neon-dot';
                
                // Posición aleatoria
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                
                // Tamaño y animación aleatoria
                const size = 1 + Math.random() * 3;
                const duration = 3 + Math.random() * 7;
                const delay = Math.random() * 5;
                
                dot.style.left = `${posX}%`;
                dot.style.top = `${posY}%`;
                dot.style.width = `${size}px`;
                dot.style.height = `${size}px`;
                dot.style.animation = `pulse ${duration}s ${delay}s infinite alternate`;
                
                // Color aleatorio (azul, rosa o verde)
                const colors = ['0ff0fc', 'ff00ff', '00ff00'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                dot.style.backgroundColor = `#${color}`;
                dot.style.boxShadow = `0 0 8px #${color}`;
                
                container.appendChild(dot);
            }
        }

        // Cargar la cuadrícula de juegos en la página principal
        function loadGamesGrid() {
            const grid = document.getElementById('gamesGrid');
            grid.innerHTML = '';
            
            games.forEach(game => {
                const card = document.createElement('div');
                card.className = 'game-card';
                card.dataset.gameId = game.id;
                
                card.innerHTML = `
                    <div class="game-header">
                        <div class="game-number">#${game.id}</div>
                        <h3 class="game-title">${game.title}</h3>
                    </div>
                    <p class="game-desc">${game.description}</p>
                    <div class="game-footer">
                        <span class="game-difficulty ${game.difficulty}">
                            ${game.difficulty === 'easy' ? 'Fácil' : game.difficulty === 'medium' ? 'Medio' : 'Difícil'}
                        </span>
                        <button class="play-btn" data-game-id="${game.id}">
                            <i class="fas ${game.icon}"></i> Jugar
                        </button>
                    </div>
                `;
                
                grid.appendChild(card);
            });
        }

        // Configurar los botones de juego
        function setupGameButtons() {
            document.addEventListener('click', function(e) {
                // Si se hace clic en un botón "Jugar"
                if (e.target.classList.contains('play-btn') || e.target.closest('.play-btn')) {
                    const btn = e.target.classList.contains('play-btn') ? e.target : e.target.closest('.play-btn');
                    const gameId = parseInt(btn.dataset.gameId);
                    launchGame(gameId);
                }
                
                // Si se hace clic en una tarjeta de juego (pero no en el botón)
                if (e.target.closest('.game-card') && !e.target.closest('.play-btn')) {
                    const card = e.target.closest('.game-card');
                    const gameId = parseInt(card.dataset.gameId);
                    launchGame(gameId);
                }
            });
        }

        // Lanzar un juego específico
        function launchGame(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            state.currentGame = game;
            state.gamesPlayed++;
            
            // Cambiar a la página del juego
            document.getElementById('mainPage').style.display = 'none';
            document.getElementById('gamePage').style.display = 'flex';
            
            // Configurar el título del juego
            document.getElementById('currentGameTitle').textContent = game.title;
            
            // Cargar el juego correspondiente
            loadGameContent(game);
        }

        // Cargar el contenido del juego seleccionado
        function loadGameContent(game) {
            const content = document.getElementById('gameContent');
            content.innerHTML = '';
            
            // Mapeo de ID de juego a función de carga
            const gameLoaders = {
                1: loadGuessNumberGame,
                2: loadTicTacToeGame,
                3: loadSudokuGame,
                4: loadMemoryGame,
                5: loadHanoiGame,
                6: loadMinesweeperGame,
                7: loadPuzzle15Game,
                8: loadHangmanGame,
                9: loadConnect4Game,
                10: loadMazeGame,
                11: loadCryptogramGame,
                12: loadMastermindGame,
                13: loadLifeGame,
                14: loadBattleshipGame,
                15: loadNonogramGame
            };
            
            const loader = gameLoaders[game.id];
            if (loader) {
                loader(content);
            } else {
                content.innerHTML = `<div class="game-container"><h2>Juego no disponible</h2></div>`;
            }
        }

        // ==================== JUEGO 1: Adivina el Número ====================
        function loadGuessNumberGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Adivina el Número</h2>
                    
                    <p class="game-instructions">
                        He pensado en un número entre <span style="color:var(--neon-green);font-weight:bold">1</span> y 
                        <span style="color:var(--neon-green);font-weight:bold">100</span>. 
                        ¡Adivina cuál es! Te diré si es mayor o menor que tu intento.
                    </p>
                    
                    <div class="game-controls">
                        <input type="number" id="guessInput" class="game-input" min="1" max="100" placeholder="Tu número">
                        <button id="guessButton" class="game-button">Adivinar</button>
                        <button id="hintButton" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #ff5500)">Pista</button>
                        <button id="restartButton" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Reiniciar</button>
                    </div>
                    
                    <div class="game-feedback" id="feedback">
                        <p id="feedbackText">Introduce un número y haz clic en "Adivinar" para comenzar.</p>
                        <div id="hintContainer" style="display:none; margin-top:1rem;">
                            <p id="hintText" style="color:var(--neon-blue)"></p>
                        </div>
                    </div>
                    
                    <div class="game-stats">
                        <div class="stat-box">
                            <h3>Intentos</h3>
                            <p id="attemptsCount" style="font-size:2rem;color:var(--neon-blue)">0</p>
                        </div>
                        <div class="stat-box">
                            <h3>Rango</h3>
                            <p style="font-size:1.5rem;color:var(--neon-green)">1 - 100</p>
                        </div>
                        <div class="stat-box">
                            <h3>Record</h3>
                            <p id="bestScore" style="font-size:2rem;color:var(--neon-pink)">-</p>
                        </div>
                    </div>
                    
                    <div id="attemptsHistory" style="margin-top:2rem;color:var(--text-secondary);">
                        <h3 style="color:var(--neon-blue);margin-bottom:0.5rem;">Historial de intentos:</h3>
                        <div id="historyList" style="min-height:50px;padding:1rem;background:rgba(0,0,0,0.3);border-radius:8px;"></div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initGuessNumberGame();
        }

        function initGuessNumberGame() {
            let secretNumber = Math.floor(Math.random() * 100) + 1;
            let attempts = 0;
            let gameActive = true;
            let bestScore = localStorage.getItem('guessNumberBestScore') || null;
            const history = [];
            
            // Mostrar mejor puntuación si existe
            if (bestScore) {
                document.getElementById('bestScore').textContent = bestScore;
            }
            
            // Elementos del juego
            const guessInput = document.getElementById('guessInput');
            const guessButton = document.getElementById('guessButton');
            const hintButton = document.getElementById('hintButton');
            const restartButton = document.getElementById('restartButton');
            const feedbackText = document.getElementById('feedbackText');
            const hintContainer = document.getElementById('hintContainer');
            const hintText = document.getElementById('hintText');
            const attemptsCount = document.getElementById('attemptsCount');
            const historyList = document.getElementById('historyList');
            
            // Función para procesar un intento
            function processGuess() {
                if (!gameActive) return;
                
                const guess = parseInt(guessInput.value);
                
                // Validación
                if (isNaN(guess) || guess < 1 || guess > 100) {
                    feedbackText.innerHTML = `<span style="color:var(--neon-pink)">Por favor, introduce un número válido entre 1 y 100.</span>`;
                    guessInput.value = '';
                    guessInput.focus();
                    return;
                }
                
                // Incrementar intentos
                attempts++;
                attemptsCount.textContent = attempts;
                
                // Añadir al historial
                history.push(guess);
                updateHistoryList();
                
                // Comprobar si es correcto
                if (guess === secretNumber) {
                    // ¡Ganó!
                    feedbackText.innerHTML = `
                        <span style="color:var(--neon-green);font-size:1.5rem;">
                            <i class="fas fa-trophy"></i> ¡Correcto! El número era ${secretNumber}.
                        </span>
                        <p style="margin-top:0.5rem;">Lo has adivinado en ${attempts} intentos.</p>
                    `;
                    
                    gameActive = false;
                    guessButton.disabled = true;
                    hintButton.disabled = true;
                    
                    // Actualizar mejor puntuación
                    if (!bestScore || attempts < bestScore) {
                        bestScore = attempts;
                        document.getElementById('bestScore').textContent = bestScore;
                        localStorage.setItem('guessNumberBestScore', bestScore);
                        
                        feedbackText.innerHTML += `
                            <p style="color:var(--neon-pink);margin-top:1rem;">
                                <i class="fas fa-crown"></i> ¡Nuevo récord!
                            </p>
                        `;
                    }
                    
                    // Efecto visual de celebración
                    document.getElementById('feedback').style.boxShadow = '0 0 30px var(--neon-green)';
                    document.getElementById('feedback').style.border = '2px solid var(--neon-green)';
                    
                } else {
                    // Dar pista
                    const difference = Math.abs(secretNumber - guess);
                    let hint = '';
                    
                    if (guess < secretNumber) {
                        hint = `El número secreto es <span style="color:var(--neon-green)">MAYOR</span> que ${guess}.`;
                    } else {
                        hint = `El número secreto es <span style="color:var(--neon-pink)">MENOR</span> que ${guess}.`;
                    }
                    
                    // Añadir información adicional según la diferencia
                    if (difference > 30) {
                        hint += ` <span style="color:var(--text-secondary)">(Estás muy lejos)</span>`;
                    } else if (difference > 15) {
                        hint += ` <span style="color:var(--text-secondary)">(Estás lejos)</span>`;
                    } else if (difference > 5) {
                        hint += ` <span style="color:var(--text-secondary)">(Estás cerca)</span>`;
                    } else {
                        hint += ` <span style="color:var(--text-secondary)">(¡Estás muy cerca!)</span>`;
                    }
                    
                    feedbackText.innerHTML = hint;
                    
                    // Efecto visual de pista
                    document.getElementById('feedback').style.boxShadow = '0 0 20px var(--neon-blue)';
                    document.getElementById('feedback').style.border = '1px solid var(--neon-blue)';
                }
                
                // Limpiar campo de entrada
                guessInput.value = '';
                guessInput.focus();
                
                // Ocultar pista anterior
                hintContainer.style.display = 'none';
            }
            
            // Función para dar una pista
            function giveHint() {
                if (!gameActive) return;
                
                // Determinar tipo de pista aleatoria
                const hintType = Math.floor(Math.random() * 3);
                
                switch(hintType) {
                    case 0:
                        // Pista de par/impar
                        const parity = secretNumber % 2 === 0 ? 'par' : 'impar';
                        hintText.textContent = `El número secreto es ${parity}.`;
                        break;
                    case 1:
                        // Pista de múltiplo
                        const multiples = [3, 5, 10];
                        const multiple = multiples[Math.floor(Math.random() * multiples.length)];
                        const isMultiple = secretNumber % multiple === 0;
                        hintText.textContent = `El número secreto ${isMultiple ? 'SÍ' : 'NO'} es múltiplo de ${multiple}.`;
                        break;
                    case 2:
                        // Pista de rango reducido
                        const lowerBound = Math.max(1, secretNumber - 10);
                        const upperBound = Math.min(100, secretNumber + 10);
                        hintText.textContent = `El número está entre ${lowerBound} y ${upperBound}.`;
                        break;
                }
                
                hintContainer.style.display = 'block';
                
                // Efecto visual
                hintContainer.style.animation = 'none';
                setTimeout(() => {
                    hintContainer.style.animation = 'pulse 1s';
                }, 10);
            }
            
            // Función para reiniciar el juego
            function restartGame() {
                secretNumber = Math.floor(Math.random() * 100) + 1;
                attempts = 0;
                gameActive = true;
                history.length = 0;
                
                // Restablecer UI
                attemptsCount.textContent = '0';
                feedbackText.textContent = 'Introduce un número y haz clic en "Adivinar" para comenzar.';
                hintContainer.style.display = 'none';
                historyList.innerHTML = '';
                guessButton.disabled = false;
                hintButton.disabled = false;
                
                // Restablecer estilos
                document.getElementById('feedback').style.boxShadow = 'none';
                document.getElementById('feedback').style.border = 'none';
                
                guessInput.focus();
            }
            
            // Función para actualizar el historial
            function updateHistoryList() {
                historyList.innerHTML = '';
                
                history.forEach((attempt, index) => {
                    const attemptDiv = document.createElement('div');
                    attemptDiv.style.display = 'inline-block';
                    attemptDiv.style.margin = '5px';
                    attemptDiv.style.padding = '8px 12px';
                    attemptDiv.style.background = attempt === secretNumber ? 
                        'linear-gradient(45deg, var(--neon-green), #00aa00)' : 
                        'rgba(0, 255, 255, 0.1)';
                    attemptDiv.style.borderRadius = '5px';
                    attemptDiv.style.border = attempt === secretNumber ? 
                        '1px solid var(--neon-green)' : '1px solid var(--neon-blue)';
                    
                    attemptDiv.textContent = attempt;
                    historyList.appendChild(attemptDiv);
                });
            }
            
            // Configurar event listeners
            guessButton.addEventListener('click', processGuess);
            hintButton.addEventListener('click', giveHint);
            restartButton.addEventListener('click', restartGame);
            
            guessInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    processGuess();
                }
            });
            
            // Iniciar el juego
            guessInput.focus();
        }

        // ==================== JUEGO 2: Tres en Raya ====================
        function loadTicTacToeGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Tres en Raya</h2>
                    
                    <p class="game-instructions">
                        Juega contra la computadora. Tú eres <span style="color:var(--neon-green)">X</span> y la computadora es 
                        <span style="color:var(--neon-pink)">O</span>. Gana el primero en alinear tres símbolos.
                    </p>
                    
                    <div style="text-align:center;">
                        <div class="tic-tac-toe-board" id="ticTacToeBoard"></div>
                        
                        <div class="game-stats" style="margin-top:2rem;">
                            <div class="stat-box">
                                <h3>Turno</h3>
                                <p id="currentTurn" style="font-size:1.5rem;color:var(--neon-green)">Tú (X)</p>
                            </div>
                            <div class="stat-box">
                                <h3>Resultado</h3>
                                <p id="gameResult" style="font-size:1.5rem;color:var(--neon-blue)">En juego</p>
                            </div>
                            <div class="stat-box">
                                <h3>Récord</h3>
                                <p id="ticTacToeRecord" style="font-size:1.5rem;color:var(--neon-pink)">0-0-0</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:2rem;">
                            <button id="resetTicTacToe" class="game-button">Reiniciar</button>
                            <button id="changeDifficulty" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #ff5500)">Cambiar Dificultad</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initTicTacToeGame();
        }

        function initTicTacToeGame() {
            const boardElement = document.getElementById('ticTacToeBoard');
            const currentTurnElement = document.getElementById('currentTurn');
            const gameResultElement = document.getElementById('gameResult');
            const resetButton = document.getElementById('resetTicTacToe');
            const changeDifficultyButton = document.getElementById('changeDifficulty');
            const recordElement = document.getElementById('ticTacToeRecord');
            
            let board = ['', '', '', '', '', '', '', '', ''];
            let currentPlayer = 'X';
            let gameActive = true;
            let difficulty = 'medium'; // 'easy', 'medium', 'hard'
            let record = {
                wins: 0,
                losses: 0,
                draws: 0
            };
            
            // Cargar récord desde localStorage
            const savedRecord = localStorage.getItem('ticTacToeRecord');
            if (savedRecord) {
                record = JSON.parse(savedRecord);
                updateRecordDisplay();
            }
            
            // Patrones ganadores
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Filas
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columnas
                [0, 4, 8], [2, 4, 6]             // Diagonales
            ];
            
            // Crear el tablero
            function createBoard() {
                boardElement.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'tic-tac-toe-cell';
                    cell.dataset.index = i;
                    cell.textContent = board[i];
                    
                    // Estilo según el contenido
                    if (board[i] === 'X') {
                        cell.style.color = 'var(--neon-green)';
                        cell.style.textShadow = '0 0 10px var(--neon-green)';
                    } else if (board[i] === 'O') {
                        cell.style.color = 'var(--neon-pink)';
                        cell.style.textShadow = '0 0 10px var(--neon-pink)';
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(i));
                    boardElement.appendChild(cell);
                }
            }
            
            // Manejar clic en celda
            function handleCellClick(index) {
                if (!gameActive || board[index] !== '' || currentPlayer !== 'X') return;
                
                // Colocar X
                board[index] = 'X';
                createBoard();
                
                // Verificar si el jugador ganó
                if (checkWinner('X')) {
                    endGame('win');
                    return;
                }
                
                // Verificar empate
                if (checkDraw()) {
                    endGame('draw');
                    return;
                }
                
                // Cambiar turno a la computadora
                currentPlayer = 'O';
                currentTurnElement.textContent = 'Computadora (O)';
                currentTurnElement.style.color = 'var(--neon-pink)';
                
                // La computadora juega después de un breve retraso
                setTimeout(computerMove, 500);
            }
            
            // Movimiento de la computadora
            function computerMove() {
                if (!gameActive || currentPlayer !== 'O') return;
                
                let moveIndex;
                
                if (difficulty === 'easy') {
                    // Modo fácil: movimiento aleatorio
                    const emptyCells = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                    moveIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                } else if (difficulty === 'medium') {
                    // Modo medio: a veces bloquea, a veces aleatorio
                    if (Math.random() < 0.7) {
                        moveIndex = findWinningMove('O') || findWinningMove('X') || findRandomMove();
                    } else {
                        moveIndex = findRandomMove();
                    }
                } else {
                    // Modo difícil: minimax o estrategia avanzada
                    moveIndex = findWinningMove('O') || findWinningMove('X') || findCenterOrCorner() || findRandomMove();
                }
                
                if (moveIndex !== undefined) {
                    board[moveIndex] = 'O';
                    createBoard();
                    
                    // Verificar si la computadora ganó
                    if (checkWinner('O')) {
                        endGame('loss');
                        return;
                    }
                    
                    // Verificar empate
                    if (checkDraw()) {
                        endGame('draw');
                        return;
                    }
                    
                    // Cambiar turno al jugador
                    currentPlayer = 'X';
                    currentTurnElement.textContent = 'Tú (X)';
                    currentTurnElement.style.color = 'var(--neon-green)';
                }
            }
            
            // Encontrar movimiento ganador
            function findWinningMove(player) {
                for (let pattern of winPatterns) {
                    const [a, b, c] = pattern;
                    const cells = [board[a], board[b], board[c]];
                    
                    // Contar celdas del jugador y vacías
                    const playerCount = cells.filter(cell => cell === player).length;
                    const emptyCount = cells.filter(cell => cell === '').length;
                    
                    if (playerCount === 2 && emptyCount === 1) {
                        // Encontrar la celda vacía
                        if (board[a] === '') return a;
                        if (board[b] === '') return b;
                        if (board[c] === '') return c;
                    }
                }
                return null;
            }
            
            // Encontrar centro o esquina
            function findCenterOrCorner() {
                const corners = [0, 2, 6, 8];
                const center = 4;
                
                if (board[center] === '') return center;
                
                // Buscar esquina vacía
                const emptyCorners = corners.filter(index => board[index] === '');
                if (emptyCorners.length > 0) {
                    return emptyCorners[Math.floor(Math.random() * emptyCorners.length)];
                }
                
                return null;
            }
            
            // Movimiento aleatorio
            function findRandomMove() {
                const emptyCells = board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                return emptyCells.length > 0 ? emptyCells[Math.floor(Math.random() * emptyCells.length)] : null;
            }
            
            // Verificar ganador
            function checkWinner(player) {
                return winPatterns.some(pattern => {
                    return pattern.every(index => board[index] === player);
                });
            }
            
            // Verificar empate
            function checkDraw() {
                return board.every(cell => cell !== '');
            }
            
            // Finalizar juego
            function endGame(result) {
                gameActive = false;
                
                if (result === 'win') {
                    gameResultElement.textContent = '¡Ganaste!';
                    gameResultElement.style.color = 'var(--neon-green)';
                    record.wins++;
                } else if (result === 'loss') {
                    gameResultElement.textContent = 'Perdiste';
                    gameResultElement.style.color = 'var(--neon-pink)';
                    record.losses++;
                } else {
                    gameResultElement.textContent = 'Empate';
                    gameResultElement.style.color = 'var(--neon-blue)';
                    record.draws++;
                }
                
                updateRecordDisplay();
                saveRecord();
            }
            
            // Actualizar récord
            function updateRecordDisplay() {
                recordElement.textContent = `${record.wins}-${record.losses}-${record.draws}`;
            }
            
            // Guardar récord
            function saveRecord() {
                localStorage.setItem('ticTacToeRecord', JSON.stringify(record));
            }
            
            // Reiniciar juego
            function resetGame() {
                board = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                gameActive = true;
                
                currentTurnElement.textContent = 'Tú (X)';
                currentTurnElement.style.color = 'var(--neon-green)';
                gameResultElement.textContent = 'En juego';
                gameResultElement.style.color = 'var(--neon-blue)';
                
                createBoard();
            }
            
            // Cambiar dificultad
            function changeDifficulty() {
                if (difficulty === 'easy') {
                    difficulty = 'medium';
                    changeDifficultyButton.textContent = 'Dificultad: Media';
                    changeDifficultyButton.style.background = 'linear-gradient(45deg, #ffff00, #ffaa00)';
                } else if (difficulty === 'medium') {
                    difficulty = 'hard';
                    changeDifficultyButton.textContent = 'Dificultad: Difícil';
                    changeDifficultyButton.style.background = 'linear-gradient(45deg, #ff0000, #ff5500)';
                } else {
                    difficulty = 'easy';
                    changeDifficultyButton.textContent = 'Dificultad: Fácil';
                    changeDifficultyButton.style.background = 'linear-gradient(45deg, #00ff00, #00aaff)';
                }
                
                resetGame();
            }
            
            // Event listeners
            resetButton.addEventListener('click', resetGame);
            changeDifficultyButton.addEventListener('click', changeDifficulty);
            
            // Inicializar
            createBoard();
            changeDifficultyButton.textContent = 'Dificultad: Media';
        }

        // ==================== JUEGO 3: Sudoku ====================
        function loadSudokuGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Sudoku</h2>
                    
                    <p class="game-instructions">
                        Completa la cuadrícula 9x9 con números del 1 al 9, sin repetir en filas, columnas o regiones 3x3.
                        Los números en azul son fijos y no se pueden cambiar.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="sudoku-board" id="sudokuBoard"></div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <div id="sudokuNumberPad" style="display:flex; justify-content:center; gap:5px; margin-bottom:15px; flex-wrap:wrap;">
                                ${Array(9).fill().map((_, i) => `
                                    <button class="sudoku-number-btn" data-number="${i+1}" style="width:50px;height:50px;font-size:1.5rem;background:rgba(0,255,255,0.1);border:2px solid var(--neon-blue);color:white;cursor:pointer;border-radius:5px;">${i+1}</button>
                                `).join('')}
                                <button id="sudokuClear" style="width:50px;height:50px;font-size:1.5rem;background:rgba(255,0,255,0.1);border:2px solid var(--neon-pink);color:white;cursor:pointer;border-radius:5px;">C</button>
                            </div>
                            
                            <div>
                                <button id="sudokuCheck" class="game-button">Comprobar</button>
                                <button id="sudokuHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista</button>
                                <button id="sudokuReset" class="game-button" style="background:linear-gradient(45deg, #ff0000, #ff5500)">Reiniciar</button>
                                <button id="sudokuNew" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Nuevo Juego</button>
                            </div>
                        </div>
                        
                        <div class="game-feedback" id="sudokuFeedback" style="margin-top:20px;">
                            <p id="sudokuMessage">Selecciona una celda y luego un número para jugar.</p>
                            <p id="sudokuErrors" style="color:var(--neon-pink); margin-top:10px; font-size:0.9rem;">Errores: <span id="errorCount">0</span>/3</p>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="sudokuTimer" style="font-size:1.5rem;color:var(--neon-green)">00:00</p>
                            </div>
                            <div class="stat-box">
                                <h3>Dificultad</h3>
                                <p id="sudokuDifficulty" style="font-size:1.5rem;color:var(--neon-blue)">Media</p>
                            </div>
                            <div class="stat-box">
                                <h3>Pistas</h3>
                                <p id="sudokuHintsLeft" style="font-size:1.5rem;color:var(--neon-pink)">3</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initSudokuGame();
        }

        function initSudokuGame() {
            // Tablero inicial (0 = vacío)
            const initialBoard = [
                [5, 3, 0, 0, 7, 0, 0, 0, 0],
                [6, 0, 0, 1, 9, 5, 0, 0, 0],
                [0, 9, 8, 0, 0, 0, 0, 6, 0],
                [8, 0, 0, 0, 6, 0, 0, 0, 3],
                [4, 0, 0, 8, 0, 3, 0, 0, 1],
                [7, 0, 0, 0, 2, 0, 0, 0, 6],
                [0, 6, 0, 0, 0, 0, 2, 8, 0],
                [0, 0, 0, 4, 1, 9, 0, 0, 5],
                [0, 0, 0, 0, 8, 0, 0, 7, 9]
            ];
            
            let board = JSON.parse(JSON.stringify(initialBoard));
            let solution = [
                [5, 3, 4, 6, 7, 8, 9, 1, 2],
                [6, 7, 2, 1, 9, 5, 3, 4, 8],
                [1, 9, 8, 3, 4, 2, 5, 6, 7],
                [8, 5, 9, 7, 6, 1, 4, 2, 3],
                [4, 2, 6, 8, 5, 3, 7, 9, 1],
                [7, 1, 3, 9, 2, 4, 8, 5, 6],
                [9, 6, 1, 5, 3, 7, 2, 8, 4],
                [2, 8, 7, 4, 1, 9, 6, 3, 5],
                [3, 4, 5, 2, 8, 6, 1, 7, 9]
            ];
            
            let selectedCell = null;
            let errors = 0;
            let hintsLeft = 3;
            let timer = 0;
            let timerInterval = null;
            let gameActive = true;
            
            const boardElement = document.getElementById('sudokuBoard');
            const sudokuMessage = document.getElementById('sudokuMessage');
            const errorCountElement = document.getElementById('errorCount');
            const hintsLeftElement = document.getElementById('sudokuHintsLeft');
            const timerElement = document.getElementById('sudokuTimer');
            const difficultyElement = document.getElementById('sudokuDifficulty');
            
            // Crear el tablero
            function createBoard() {
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'sudoku-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Determinar región para el color de fondo
                        const region = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                        cell.classList.add(`sudoku-region-${region}`);
                        
                        // Si es una celda fija (parte del tablero inicial)
                        if (initialBoard[row][col] !== 0) {
                            cell.classList.add('fixed');
                            cell.textContent = initialBoard[row][col];
                            cell.style.cursor = 'default';
                            cell.style.color = 'var(--neon-blue)';
                            cell.style.fontWeight = 'bold';
                        } else if (board[row][col] !== 0) {
                            // Celda llenada por el usuario
                            cell.textContent = board[row][col];
                            cell.style.color = 'white';
                            cell.style.fontWeight = 'normal';
                        }
                        
                        // Resaltar celdas en la misma fila/columna/región
                        cell.addEventListener('mouseenter', () => highlightRelatedCells(row, col));
                        cell.addEventListener('mouseleave', removeHighlights);
                        
                        cell.addEventListener('click', () => selectCell(row, col));
                        boardElement.appendChild(cell);
                    }
                }
                
                // Si hay una celda seleccionada, resaltarla
                if (selectedCell) {
                    const {row, col} = selectedCell;
                    const cell = boardElement.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.add('selected');
                    }
                }
            }
            
            // Seleccionar celda
            function selectCell(row, col) {
                // No permitir seleccionar celdas fijas
                if (initialBoard[row][col] !== 0) return;
                
                // Quitar selección anterior
                if (selectedCell) {
                    const prevCell = boardElement.querySelector(`.sudoku-cell[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`);
                    if (prevCell) prevCell.classList.remove('selected');
                }
                
                // Seleccionar nueva celda
                selectedCell = {row, col};
                const cell = boardElement.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.classList.add('selected');
                    sudokuMessage.textContent = `Celda seleccionada: fila ${row + 1}, columna ${col + 1}`;
                }
            }
            
            // Resaltar celdas relacionadas
            function highlightRelatedCells(row, col) {
                const cells = boardElement.querySelectorAll('.sudoku-cell');
                cells.forEach(cell => {
                    const cellRow = parseInt(cell.dataset.row);
                    const cellCol = parseInt(cell.dataset.col);
                    
                    // Misma fila, misma columna o misma región
                    if (cellRow === row || cellCol === col || 
                        (Math.floor(cellRow / 3) === Math.floor(row / 3) && Math.floor(cellCol / 3) === Math.floor(col / 3))) {
                        cell.classList.add('highlighted');
                    }
                });
            }
            
            // Quitar resaltados
            function removeHighlights() {
                const cells = boardElement.querySelectorAll('.sudoku-cell');
                cells.forEach(cell => {
                    cell.classList.remove('highlighted');
                });
            }
            
            // Colocar número
            function placeNumber(number) {
                if (!selectedCell || !gameActive) return;
                
                const {row, col} = selectedCell;
                
                // No permitir modificar celdas fijas
                if (initialBoard[row][col] !== 0) return;
                
                // Verificar si el número es válido
                const isValid = checkNumberValidity(row, col, number);
                
                // Actualizar tablero
                board[row][col] = number;
                createBoard();
                
                // Verificar si el juego está completo
                if (isBoardComplete()) {
                    endGame(true);
                } else if (!isValid) {
                    // Número incorrecto
                    errors++;
                    errorCountElement.textContent = errors;
                    
                    if (errors >= 3) {
                        endGame(false);
                    } else {
                        sudokuMessage.innerHTML = `<span style="color:var(--neon-pink)">Número incorrecto en fila ${row + 1}, columna ${col + 1}</span>`;
                    }
                }
            }
            
            // Verificar validez de un número
            function checkNumberValidity(row, col, number) {
                // Verificar fila
                for (let c = 0; c < 9; c++) {
                    if (c !== col && board[row][c] === number) return false;
                }
                
                // Verificar columna
                for (let r = 0; r < 9; r++) {
                    if (r !== row && board[r][col] === number) return false;
                }
                
                // Verificar región 3x3
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                
                for (let r = startRow; r < startRow + 3; r++) {
                    for (let c = startCol; c < startCol + 3; c++) {
                        if (r !== row && c !== col && board[r][c] === number) return false;
                    }
                }
                
                return true;
            }
            
            // Verificar si el tablero está completo
            function isBoardComplete() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === 0) return false;
                    }
                }
                return true;
            }
            
            // Dar pista
            function giveHint() {
                if (!selectedCell || hintsLeft <= 0 || !gameActive) return;
                
                const {row, col} = selectedCell;
                
                // No dar pistas para celdas fijas
                if (initialBoard[row][col] !== 0) return;
                
                // Mostrar el número correcto
                const correctNumber = solution[row][col];
                board[row][col] = correctNumber;
                hintsLeft--;
                hintsLeftElement.textContent = hintsLeft;
                
                createBoard();
                sudokuMessage.innerHTML = `<span style="color:var(--neon-green)">Pista: el número correcto es ${correctNumber}</span>`;
                
                // Verificar si el juego está completo
                if (isBoardComplete()) {
                    endGame(true);
                }
            }
            
            // Comprobar solución
            function checkSolution() {
                if (!gameActive) return;
                
                let correct = true;
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] !== solution[row][col]) {
                            correct = false;
                            break;
                        }
                    }
                    if (!correct) break;
                }
                
                if (correct) {
                    endGame(true);
                } else {
                    sudokuMessage.innerHTML = `<span style="color:var(--neon-pink)">Hay errores en la solución. Sigue intentando.</span>`;
                }
            }
            
            // Finalizar juego
            function endGame(success) {
                gameActive = false;
                clearInterval(timerInterval);
                
                if (success) {
                    sudokuMessage.innerHTML = `<span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Sudoku resuelto correctamente en ${formatTime(timer)}.
                    </span>`;
                    
                    // Mostrar todos los números correctos
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            if (initialBoard[row][col] === 0) {
                                board[row][col] = solution[row][col];
                            }
                        }
                    }
                    createBoard();
                } else {
                    sudokuMessage.innerHTML = `<span style="color:var(--neon-pink); font-size:1.2rem;">
                        <i class="fas fa-times-circle"></i> Demasiados errores. El juego ha terminado.
                    </span>`;
                }
            }
            
            // Reiniciar juego
            function resetGame() {
                board = JSON.parse(JSON.stringify(initialBoard));
                selectedCell = null;
                errors = 0;
                hintsLeft = 3;
                gameActive = true;
                
                errorCountElement.textContent = errors;
                hintsLeftElement.textContent = hintsLeft;
                sudokuMessage.textContent = 'Selecciona una celda y luego un número para jugar.';
                
                createBoard();
                
                // Reiniciar timer si está corriendo
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                timer = 0;
                timerElement.textContent = '00:00';
                startTimer();
            }
            
            // Nuevo juego
            function newGame() {
                // Podríamos implementar diferentes tableros aquí
                // Por simplicidad, reiniciamos con el mismo tablero
                resetGame();
                sudokuMessage.textContent = 'Nuevo juego comenzado. ¡Buena suerte!';
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    timerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Configurar event listeners
            // Botones numéricos
            document.querySelectorAll('.sudoku-number-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const number = parseInt(btn.dataset.number);
                    placeNumber(number);
                });
            });
            
            // Botón limpiar
            document.getElementById('sudokuClear').addEventListener('click', () => {
                if (selectedCell && gameActive) {
                    const {row, col} = selectedCell;
                    if (initialBoard[row][col] === 0) {
                        board[row][col] = 0;
                        createBoard();
                        sudokuMessage.textContent = 'Celda limpiada.';
                    }
                }
            });
            
            // Otros botones
            document.getElementById('sudokuCheck').addEventListener('click', checkSolution);
            document.getElementById('sudokuHint').addEventListener('click', giveHint);
            document.getElementById('sudokuReset').addEventListener('click', resetGame);
            document.getElementById('sudokuNew').addEventListener('click', newGame);
            
            // Inicializar
            createBoard();
            startTimer();
        }

        // ==================== JUEGO 4: Memorama ====================
        function loadMemoryGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Memorama</h2>
                    
                    <p class="game-instructions">
                        Encuentra todas las parejas de cartas iguales. Haz clic en dos cartas para voltearlas. 
                        Si son iguales, se quedarán descubiertas. ¡Encuentra todas las parejas en el menor tiempo posible!
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="memory-board" id="memoryBoard"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Parejas</h3>
                                <p id="pairsFound" style="font-size:1.5rem;color:var(--neon-green)">0/8</p>
                            </div>
                            <div class="stat-box">
                                <h3>Movimientos</h3>
                                <p id="movesCount" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="memoryTimer" style="font-size:1.5rem;color:var(--neon-pink)">00:00</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="memoryReset" class="game-button">Reiniciar</button>
                            <button id="memoryHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista (3)</button>
                            <button id="memoryChangeSize" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Cambiar Tamaño</button>
                        </div>
                        
                        <div class="game-feedback" id="memoryFeedback" style="margin-top:20px;">
                            <p id="memoryMessage">Haz clic en una carta para comenzar.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initMemoryGame();
        }

        function initMemoryGame() {
            // Símbolos para las cartas (8 parejas = 16 cartas)
            const symbols = ['🚀', '🎮', '👾', '🕹️', '🎯', '⭐', '🔮', '🎨'];
            let cards = [];
            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;
            let canFlip = true;
            let timer = 0;
            let timerInterval = null;
            let hintsLeft = 3;
            let boardSize = 4; // 4x4 tablero
            
            const boardElement = document.getElementById('memoryBoard');
            const pairsFoundElement = document.getElementById('pairsFound');
            const movesCountElement = document.getElementById('movesCount');
            const timerElement = document.getElementById('memoryTimer');
            const memoryMessage = document.getElementById('memoryMessage');
            const hintButton = document.getElementById('memoryHint');
            
            // Inicializar juego
            function initGame() {
                // Crear mazo de cartas (duplicar símbolos para tener parejas)
                cards = [];
                symbols.slice(0, boardSize * boardSize / 2).forEach(symbol => {
                    cards.push(symbol);
                    cards.push(symbol);
                });
                
                // Barajar cartas
                shuffleArray(cards);
                
                // Reiniciar estado del juego
                flippedCards = [];
                matchedPairs = 0;
                moves = 0;
                canFlip = true;
                hintsLeft = 3;
                
                pairsFoundElement.textContent = `0/${boardSize * boardSize / 2}`;
                movesCountElement.textContent = '0';
                memoryMessage.textContent = 'Haz clic en una carta para comenzar.';
                hintButton.textContent = `Pista (${hintsLeft})`;
                
                // Reiniciar timer
                if (timerInterval) clearInterval(timerInterval);
                timer = 0;
                timerElement.textContent = '00:00';
                startTimer();
                
                // Crear tablero
                createBoard();
            }
            
            // Barajar array
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            // Crear tablero
            function createBoard() {
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
                boardElement.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;
                boardElement.style.width = `${boardSize * 100}px`;
                boardElement.style.height = `${boardSize * 100}px`;
                
                for (let i = 0; i < cards.length; i++) {
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.dataset.index = i;
                    card.dataset.symbol = cards[i];
                    
                    const front = document.createElement('div');
                    front.className = 'memory-card-front';
                    front.textContent = '?';
                    
                    const back = document.createElement('div');
                    back.className = 'memory-card-back';
                    back.textContent = cards[i];
                    
                    card.appendChild(front);
                    card.appendChild(back);
                    
                    card.addEventListener('click', () => flipCard(i));
                    boardElement.appendChild(card);
                }
            }
            
            // Voltear carta
            function flipCard(index) {
                if (!canFlip) return;
                
                const card = boardElement.querySelector(`.memory-card[data-index="${index}"]`);
                if (!card || card.classList.contains('flipped') || card.classList.contains('matched')) return;
                
                // Voltear carta
                card.classList.add('flipped');
                flippedCards.push({index, element: card});
                
                // Si se han volteado 2 cartas
                if (flippedCards.length === 2) {
                    moves++;
                    movesCountElement.textContent = moves;
                    canFlip = false;
                    
                    const [card1, card2] = flippedCards;
                    
                    // Comprobar si son pareja
                    if (cards[card1.index] === cards[card2.index]) {
                        // Son pareja
                        setTimeout(() => {
                            card1.element.classList.add('matched');
                            card2.element.classList.add('matched');
                            flippedCards = [];
                            canFlip = true;
                            
                            matchedPairs++;
                            pairsFoundElement.textContent = `${matchedPairs}/${boardSize * boardSize / 2}`;
                            memoryMessage.innerHTML = `<span style="color:var(--neon-green)">¡Encontraste una pareja!</span>`;
                            
                            // Verificar si se completó el juego
                            if (matchedPairs === boardSize * boardSize / 2) {
                                endGame();
                            }
                        }, 500);
                    } else {
                        // No son pareja, voltear de nuevo después de un segundo
                        setTimeout(() => {
                            card1.element.classList.remove('flipped');
                            card2.element.classList.remove('flipped');
                            flippedCards = [];
                            canFlip = true;
                            memoryMessage.innerHTML = `<span style="color:var(--neon-pink)">No son pareja. ¡Sigue intentando!</span>`;
                        }, 1000);
                    }
                } else {
                    // Solo una carta volteada
                    memoryMessage.textContent = 'Selecciona otra carta para encontrar la pareja.';
                }
            }
            
            // Dar pista
            function giveHint() {
                if (hintsLeft <= 0 || matchedPairs === cards.length / 2) return;
                
                // Encontrar cartas no emparejadas
                const unpairedCards = [];
                const cardElements = boardElement.querySelectorAll('.memory-card');
                
                cardElements.forEach((card, index) => {
                    if (!card.classList.contains('matched') && !card.classList.contains('flipped')) {
                        unpairedCards.push({index, element: card});
                    }
                });
                
                if (unpairedCards.length >= 2) {
                    // Encontrar una pareja
                    const symbolMap = {};
                    let pairFound = false;
                    let hintCards = [];
                    
                    for (const card of unpairedCards) {
                        const symbol = cards[card.index];
                        if (symbolMap[symbol]) {
                            // ¡Encontramos una pareja!
                            hintCards = [symbolMap[symbol], card];
                            pairFound = true;
                            break;
                        } else {
                            symbolMap[symbol] = card;
                        }
                    }
                    
                    if (pairFound) {
                        // Mostrar pista (voltear brevemente las cartas)
                        hintCards.forEach(card => {
                            card.element.classList.add('flipped');
                        });
                        
                        setTimeout(() => {
                            hintCards.forEach(card => {
                                card.element.classList.remove('flipped');
                            });
                        }, 1000);
                        
                        hintsLeft--;
                        hintButton.textContent = `Pista (${hintsLeft})`;
                        memoryMessage.innerHTML = `<span style="color:var(--neon-yellow)">Pista mostrada. ¡Busca estas cartas!</span>`;
                    }
                }
            }
            
            // Cambiar tamaño del tablero
            function changeBoardSize() {
                if (boardSize === 4) {
                    boardSize = 6;
                    // Necesitamos más símbolos para un tablero 6x6 (18 parejas)
                    while (symbols.length < 18) {
                        symbols.push(String.fromCodePoint(0x1F300 + Math.floor(Math.random() * 100)));
                    }
                } else if (boardSize === 6) {
                    boardSize = 4;
                }
                
                initGame();
                memoryMessage.textContent = `Tablero cambiado a ${boardSize}x${boardSize}. ¡Buena suerte!`;
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    timerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Finalizar juego
            function endGame() {
                clearInterval(timerInterval);
                canFlip = false;
                
                // Mostrar mensaje de felicitación
                const score = Math.max(1000 - (moves * 10 + timer * 5), 100);
                memoryMessage.innerHTML = `
                    <span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Completaste el juego en ${moves} movimientos y ${formatTime(timer)}.
                    </span>
                    <p style="margin-top:10px;color:var(--neon-blue)">Puntuación: ${score} puntos</p>
                `;
                
                // Guardar récord si es mejor
                const bestScore = localStorage.getItem('memoryBestScore') || 0;
                if (score > bestScore) {
                    localStorage.setItem('memoryBestScore', score);
                    memoryMessage.innerHTML += `
                        <p style="color:var(--neon-pink);margin-top:5px;">
                            <i class="fas fa-crown"></i> ¡Nuevo récord!
                        </p>
                    `;
                }
            }
            
            // Configurar event listeners
            document.getElementById('memoryReset').addEventListener('click', initGame);
            document.getElementById('memoryHint').addEventListener('click', giveHint);
            document.getElementById('memoryChangeSize').addEventListener('click', changeBoardSize);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 5: Torres de Hanoi ====================
        function loadHanoiGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Torres de Hanoi</h2>
                    
                    <p class="game-instructions">
                        Mueve todos los discos de la torre izquierda a la torre derecha, siguiendo estas reglas:<br>
                        1. Solo puedes mover un disco a la vez.<br>
                        2. Solo puedes mover el disco superior de una torre.<br>
                        3. No puedes colocar un disco grande sobre uno pequeño.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="hanoi-container" id="hanoiContainer">
                            <div class="hanoi-tower" id="tower1" data-tower="1">
                                <div class="hanoi-base"></div>
                                <div class="hanoi-pole"></div>
                                <div id="tower1Discs" class="hanoi-discs"></div>
                            </div>
                            <div class="hanoi-tower" id="tower2" data-tower="2">
                                <div class="hanoi-base"></div>
                                <div class="hanoi-pole"></div>
                                <div id="tower2Discs" class="hanoi-discs"></div>
                            </div>
                            <div class="hanoi-tower" id="tower3" data-tower="3">
                                <div class="hanoi-base"></div>
                                <div class="hanoi-pole"></div>
                                <div id="tower3Discs" class="hanoi-discs"></div>
                            </div>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Discos</h3>
                                <p id="diskCount" style="font-size:1.5rem;color:var(--neon-green)">3</p>
                            </div>
                            <div class="stat-box">
                                <h3>Movimientos</h3>
                                <p id="hanoiMoves" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Mínimo</h3>
                                <p id="minMoves" style="font-size:1.5rem;color:var(--neon-pink)">7</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="hanoiReset" class="game-button">Reiniciar</button>
                            <button id="hanoiUndo" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Deshacer</button>
                            <button id="hanoiChangeDisks" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Cambiar Discos</button>
                            <button id="hanoiSolve" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #ff5500)">Resolver</button>
                        </div>
                        
                        <div class="game-feedback" id="hanoiFeedback" style="margin-top:20px;">
                            <p id="hanoiMessage">Haz clic en una torre para seleccionar un disco, luego en otra torre para moverlo.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initHanoiGame();
        }

        function initHanoiGame() {
            let towers = [[], [], []];
            let selectedTower = null;
            let moves = 0;
            let moveHistory = [];
            let diskCount = 3;
            let solving = false;
            
            const container = document.getElementById('hanoiContainer');
            const hanoiMovesElement = document.getElementById('hanoiMoves');
            const minMovesElement = document.getElementById('minMoves');
            const diskCountElement = document.getElementById('diskCount');
            const hanoiMessage = document.getElementById('hanoiMessage');
            
            // Inicializar juego
            function initGame() {
                // Reiniciar torres
                towers = [[], [], []];
                selectedTower = null;
                moves = 0;
                moveHistory = [];
                
                // Llenar la primera torre con discos
                for (let i = diskCount; i > 0; i--) {
                    towers[0].push(i);
                }
                
                // Actualizar UI
                hanoiMovesElement.textContent = moves;
                minMovesElement.textContent = Math.pow(2, diskCount) - 1;
                diskCountElement.textContent = diskCount;
                hanoiMessage.textContent = 'Haz clic en una torre para seleccionar un disco, luego en otra torre para moverlo.';
                
                // Renderizar torres
                renderTowers();
            }
            
            // Renderizar torres
            function renderTowers() {
                // Limpiar torres
                for (let i = 1; i <= 3; i++) {
                    const towerDiscs = document.getElementById(`tower${i}Discs`);
                    towerDiscs.innerHTML = '';
                    
                    // Quitar clase selected
                    const towerElement = document.getElementById(`tower${i}`);
                    towerElement.classList.remove('selected');
                }
                
                // Añadir discos a cada torre
                for (let i = 0; i < 3; i++) {
                    const towerDiscs = document.getElementById(`tower${i+1}Discs`);
                    
                    // Añadir discos de abajo hacia arriba
                    for (let j = towers[i].length - 1; j >= 0; j--) {
                        const disk = document.createElement('div');
                        disk.className = 'hanoi-disk';
                        disk.dataset.size = towers[i][j];
                        
                        // Tamaño y color del disco
                        const size = towers[i][j];
                        const width = 40 + size * 20;
                        const hue = (size * 40) % 360;
                        
                        disk.style.width = `${width}%`;
                        disk.style.background = `linear-gradient(45deg, hsl(${hue}, 100%, 50%), hsl(${hue + 20}, 100%, 30%))`;
                        disk.style.border = `2px solid hsl(${hue}, 100%, 70%)`;
                        
                        towerDiscs.appendChild(disk);
                    }
                }
                
                // Resaltar torre seleccionada
                if (selectedTower !== null) {
                    const towerElement = document.getElementById(`tower${selectedTower + 1}`);
                    towerElement.classList.add('selected');
                    
                    // Resaltar disco superior seleccionado
                    const topDisk = towerElement.querySelector('.hanoi-disk:last-child');
                    if (topDisk) {
                        topDisk.classList.add('selected');
                    }
                }
            }
            
            // Manejar clic en torre
            function handleTowerClick(towerIndex) {
                if (solving) return;
                
                if (selectedTower === null) {
                    // Seleccionar una torre
                    if (towers[towerIndex].length > 0) {
                        selectedTower = towerIndex;
                        hanoiMessage.textContent = `Torre ${towerIndex + 1} seleccionada. Ahora haz clic en una torre destino.`;
                        renderTowers();
                    } else {
                        hanoiMessage.innerHTML = `<span style="color:var(--neon-pink)">La torre ${towerIndex + 1} está vacía. Selecciona una torre con discos.</span>`;
                    }
                } else {
                    // Mover disco de torre seleccionada a torre destino
                    if (selectedTower === towerIndex) {
                        // Deseleccionar
                        selectedTower = null;
                        hanoiMessage.textContent = 'Selección cancelada. Haz clic en una torre para seleccionar un disco.';
                        renderTowers();
                    } else {
                        // Intentar mover disco
                        moveDisk(selectedTower, towerIndex);
                    }
                }
            }
            
            // Mover disco
            function moveDisk(fromIndex, toIndex) {
                if (towers[fromIndex].length === 0) {
                    hanoiMessage.innerHTML = `<span style="color:var(--neon-pink)">No hay discos en la torre ${fromIndex + 1}.</span>`;
                    selectedTower = null;
                    renderTowers();
                    return;
                }
                
                const diskToMove = towers[fromIndex][towers[fromIndex].length - 1];
                
                // Verificar si el movimiento es válido
                if (towers[toIndex].length === 0 || diskToMove < towers[toIndex][towers[toIndex].length - 1]) {
                    // Movimiento válido
                    towers[fromIndex].pop();
                    towers[toIndex].push(diskToMove);
                    moves++;
                    
                    // Guardar movimiento en el historial
                    moveHistory.push({from: fromIndex, to: toIndex, disk: diskToMove});
                    
                    // Actualizar UI
                    hanoiMovesElement.textContent = moves;
                    hanoiMessage.innerHTML = `<span style="color:var(--neon-green)">Disco ${diskToMove} movido de torre ${fromIndex + 1} a torre ${toIndex + 1}.</span>`;
                    
                    // Verificar si se ganó
                    if (towers[2].length === diskCount) {
                        endGame();
                    }
                } else {
                    // Movimiento inválido
                    hanoiMessage.innerHTML = `<span style="color:var(--neon-pink)">No puedes colocar un disco grande sobre uno pequeño.</span>`;
                }
                
                selectedTower = null;
                renderTowers();
            }
            
            // Deshacer movimiento
            function undoMove() {
                if (moveHistory.length === 0 || solving) return;
                
                const lastMove = moveHistory.pop();
                towers[lastMove.to].pop();
                towers[lastMove.from].push(lastMove.disk);
                moves--;
                
                hanoiMovesElement.textContent = moves;
                hanoiMessage.innerHTML = `<span style="color:var(--neon-yellow)">Movimiento deshecho. Disco ${lastMove.disk} devuelto a torre ${lastMove.from + 1}.</span>`;
                
                renderTowers();
            }
            
            // Cambiar número de discos
            function changeDiskCount() {
                if (solving) return;
                
                if (diskCount === 3) {
                    diskCount = 4;
                } else if (diskCount === 4) {
                    diskCount = 5;
                } else if (diskCount === 5) {
                    diskCount = 6;
                } else {
                    diskCount = 3;
                }
                
                initGame();
                hanoiMessage.textContent = `Juego con ${diskCount} discos. El mínimo de movimientos es ${Math.pow(2, diskCount) - 1}.`;
            }
            
            // Resolver automáticamente
            function solveGame() {
                if (solving) return;
                
                solving = true;
                hanoiMessage.textContent = 'Resolviendo...';
                
                // Algoritmo recursivo para Torres de Hanoi
                const moveSequence = [];
                function hanoi(n, from, to, aux) {
                    if (n === 0) return;
                    hanoi(n - 1, from, aux, to);
                    moveSequence.push({from, to});
                    hanoi(n - 1, aux, to, from);
                }
                
                hanoi(diskCount, 0, 2, 1);
                
                // Ejecutar movimientos con animación
                let moveIndex = 0;
                function executeNextMove() {
                    if (moveIndex >= moveSequence.length) {
                        solving = false;
                        hanoiMessage.innerHTML = `<span style="color:var(--neon-green)">¡Resuelto! Solución completa en ${moveSequence.length} movimientos.</span>`;
                        return;
                    }
                    
                    const move = moveSequence[moveIndex];
                    moveDisk(move.from, move.to);
                    
                    moveIndex++;
                    setTimeout(executeNextMove, 800);
                }
                
                // Comenzar la solución
                setTimeout(executeNextMove, 500);
            }
            
            // Finalizar juego
            function endGame() {
                hanoiMessage.innerHTML = `
                    <span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Resolviste las Torres de Hanoi con ${diskCount} discos en ${moves} movimientos.
                    </span>
                    <p style="margin-top:10px;color:var(--neon-blue)">Mínimo teórico: ${Math.pow(2, diskCount) - 1} movimientos</p>
                `;
                
                // Guardar récord si es mejor
                const bestMovesKey = `hanoiBestMoves_${diskCount}`;
                const bestMoves = localStorage.getItem(bestMovesKey) || Infinity;
                
                if (moves < bestMoves) {
                    localStorage.setItem(bestMovesKey, moves);
                    hanoiMessage.innerHTML += `
                        <p style="color:var(--neon-pink);margin-top:5px;">
                            <i class="fas fa-crown"></i> ¡Nuevo récord para ${diskCount} discos!
                        </p>
                    `;
                }
            }
            
            // Configurar event listeners
            for (let i = 1; i <= 3; i++) {
                document.getElementById(`tower${i}`).addEventListener('click', () => handleTowerClick(i - 1));
            }
            
            document.getElementById('hanoiReset').addEventListener('click', () => {
                solving = false;
                initGame();
            });
            
            document.getElementById('hanoiUndo').addEventListener('click', undoMove);
            document.getElementById('hanoiChangeDisks').addEventListener('click', changeDiskCount);
            document.getElementById('hanoiSolve').addEventListener('click', solveGame);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 6: Busca Minas ====================
        function loadMinesweeperGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Busca Minas</h2>
                    
                    <p class="game-instructions">
                        Encuentra todas las minas sin activar ninguna. Los números indican cuántas minas hay en las casillas adyacentes.
                        Haz clic izquierdo para revelar una casilla, clic derecho para marcar una mina.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="game-controls" style="margin-bottom:20px;">
                            <select id="difficultySelect" style="padding:10px; background:rgba(0,255,255,0.1); color:white; border:1px solid var(--neon-blue); border-radius:5px;">
                                <option value="easy">Fácil (8x8, 10 minas)</option>
                                <option value="medium" selected>Medio (12x12, 20 minas)</option>
                                <option value="hard">Difícil (16x16, 40 minas)</option>
                            </select>
                            <button id="minesweeperNew" class="game-button">Nuevo Juego</button>
                        </div>
                        
                        <div class="minesweeper-board" id="minesweeperBoard"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Minas</h3>
                                <p id="minesCount" style="font-size:1.5rem;color:var(--neon-green)">20</p>
                            </div>
                            <div class="stat-box">
                                <h3>Marcadas</h3>
                                <p id="flagsCount" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="minesweeperTimer" style="font-size:1.5rem;color:var(--neon-pink)">00:00</p>
                            </div>
                        </div>
                        
                        <div class="game-feedback" id="minesweeperFeedback" style="margin-top:20px;">
                            <p id="minesweeperMessage">Haz clic en cualquier casilla para comenzar. ¡Buena suerte!</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initMinesweeperGame();
        }

        function initMinesweeperGame() {
            let board = [];
            let mineCount = 20;
            let flags = 0;
            let revealed = 0;
            let gameOver = false;
            let gameWon = false;
            let firstClick = true;
            let timer = 0;
            let timerInterval = null;
            
            const boardElement = document.getElementById('minesweeperBoard');
            const minesCountElement = document.getElementById('minesCount');
            const flagsCountElement = document.getElementById('flagsCount');
            const timerElement = document.getElementById('minesweeperTimer');
            const minesweeperMessage = document.getElementById('minesweeperMessage');
            const difficultySelect = document.getElementById('difficultySelect');
            
            // Configuración de dificultad
            const difficulties = {
                easy: {rows: 8, cols: 8, mines: 10},
                medium: {rows: 12, cols: 12, mines: 20},
                hard: {rows: 16, cols: 16, mines: 40}
            };
            
            let currentDifficulty = 'medium';
            let rows = 12, cols = 12;
            
            // Inicializar juego
            function initGame() {
                // Obtener configuración de dificultad
                currentDifficulty = difficultySelect.value;
                const config = difficulties[currentDifficulty];
                rows = config.rows;
                cols = config.cols;
                mineCount = config.mines;
                
                // Reiniciar estado del juego
                board = [];
                flags = 0;
                revealed = 0;
                gameOver = false;
                gameWon = false;
                firstClick = true;
                
                // Reiniciar timer
                if (timerInterval) clearInterval(timerInterval);
                timer = 0;
                timerElement.textContent = '00:00';
                
                // Actualizar UI
                minesCountElement.textContent = mineCount;
                flagsCountElement.textContent = flags;
                minesweeperMessage.textContent = 'Haz clic en cualquier casilla para comenzar. ¡Buena suerte!';
                
                // Crear tablero vacío
                for (let r = 0; r < rows; r++) {
                    board[r] = [];
                    for (let c = 0; c < cols; c++) {
                        board[r][c] = {
                            isMine: false,
                            isRevealed: false,
                            isFlagged: false,
                            neighborMines: 0
                        };
                    }
                }
                
                // Renderizar tablero
                renderBoard();
            }
            
            // Colocar minas (evitando la primera casilla clickeada)
            function placeMines(firstRow, firstCol) {
                let minesPlaced = 0;
                
                while (minesPlaced < mineCount) {
                    const r = Math.floor(Math.random() * rows);
                    const c = Math.floor(Math.random() * cols);
                    
                    // No colocar mina en la primera casilla clickeada o sus adyacentes
                    if (Math.abs(r - firstRow) <= 1 && Math.abs(c - firstCol) <= 1) {
                        continue;
                    }
                    
                    if (!board[r][c].isMine) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                        
                        // Incrementar contador de minas adyacentes
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                                    board[nr][nc].neighborMines++;
                                }
                            }
                        }
                    }
                }
            }
            
            // Renderizar tablero
            function renderBoard() {
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${cols}, 30px)`;
                boardElement.style.gridTemplateRows = `repeat(${rows}, 30px)`;
                boardElement.style.width = `${cols * 30 + 2}px`;
                boardElement.style.height = `${rows * 30 + 2}px`;
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'minesweeper-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        const cellData = board[r][c];
                        
                        if (cellData.isRevealed) {
                            cell.classList.add('revealed');
                            
                            if (cellData.isMine) {
                                cell.classList.add('mine');
                                cell.textContent = '💣';
                            } else if (cellData.neighborMines > 0) {
                                cell.textContent = cellData.neighborMines;
                                
                                // Colores para diferentes números
                                const colors = [
                                    '', // 0 (no se muestra)
                                    'var(--neon-blue)',    // 1
                                    'var(--neon-green)',   // 2
                                    'var(--neon-pink)',    // 3
                                    'var(--neon-yellow)',  // 4
                                    '#ff5500',             // 5
                                    '#00aaff',             // 6
                                    '#ff00ff',             // 7
                                    '#aaaaaa'              // 8
                                ];
                                
                                cell.style.color = colors[cellData.neighborMines] || 'white';
                                cell.style.fontWeight = 'bold';
                            }
                        } else if (cellData.isFlagged) {
                            cell.classList.add('flag');
                            cell.textContent = '🚩';
                        }
                        
                        // Event listeners
                        cell.addEventListener('click', () => handleCellClick(r, c));
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            handleRightClick(r, c);
                        });
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // Manejar clic izquierdo
            function handleCellClick(row, col) {
                if (gameOver || board[row][col].isFlagged) return;
                
                // Primer clic: colocar minas
                if (firstClick) {
                    firstClick = false;
                    placeMines(row, col);
                    startTimer();
                }
                
                // Revelar casilla
                revealCell(row, col);
                
                // Verificar si se perdió
                if (board[row][col].isMine) {
                    gameOver = true;
                    revealAllMines();
                    minesweeperMessage.innerHTML = `<span style="color:var(--neon-pink); font-size:1.2rem;">
                        <i class="fas fa-bomb"></i> ¡Boom! Perdiste.
                    </span>`;
                    clearInterval(timerInterval);
                    return;
                }
                
                // Verificar si se ganó
                if (revealed === rows * cols - mineCount) {
                    gameWon = true;
                    gameOver = true;
                    minesweeperMessage.innerHTML = `<span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Encontraste todas las minas en ${formatTime(timer)}.
                    </span>`;
                    clearInterval(timerInterval);
                    
                    // Guardar récord si es mejor
                    const bestTimeKey = `minesweeperBestTime_${currentDifficulty}`;
                    const bestTime = localStorage.getItem(bestTimeKey) || Infinity;
                    
                    if (timer < bestTime) {
                        localStorage.setItem(bestTimeKey, timer);
                        minesweeperMessage.innerHTML += `
                            <p style="color:var(--neon-pink);margin-top:5px;">
                                <i class="fas fa-crown"></i> ¡Nuevo récord!
                            </p>
                        `;
                    }
                }
                
                renderBoard();
            }
            
            // Revelar celda (con recursión para celdas vacías)
            function revealCell(row, col) {
                if (row < 0 || row >= rows || col < 0 || col >= cols) return;
                if (board[row][col].isRevealed || board[row][col].isFlagged) return;
                
                board[row][col].isRevealed = true;
                revealed++;
                
                // Si es una celda vacía (sin minas adyacentes), revelar adyacentes
                if (board[row][col].neighborMines === 0 && !board[row][col].isMine) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            revealCell(row + dr, col + dc);
                        }
                    }
                }
            }
            
            // Manejar clic derecho (bandera)
            function handleRightClick(row, col) {
                if (gameOver || board[row][col].isRevealed) return;
                
                if (board[row][col].isFlagged) {
                    // Quitar bandera
                    board[row][col].isFlagged = false;
                    flags--;
                } else {
                    // Colocar bandera
                    board[row][col].isFlagged = true;
                    flags++;
                }
                
                flagsCountElement.textContent = flags;
                renderBoard();
            }
            
            // Revelar todas las minas (al perder)
            function revealAllMines() {
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (board[r][c].isMine) {
                            board[r][c].isRevealed = true;
                        }
                    }
                }
                renderBoard();
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    timerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Configurar event listeners
            document.getElementById('minesweeperNew').addEventListener('click', initGame);
            difficultySelect.addEventListener('change', initGame);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 7: 15 Puzzle ====================
        function loadPuzzle15Game(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">15 Puzzle</h2>
                    
                    <p class="game-instructions">
                        Ordena los números del 1 al 15 en orden. Haz clic en una pieza adyacente al espacio vacío para moverla.
                        ¡Resuelve el rompecabezas en el menor número de movimientos posible!
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="puzzle15-board" id="puzzle15Board"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Movimientos</h3>
                                <p id="puzzleMoves" style="font-size:1.5rem;color:var(--neon-green)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="puzzleTimer" style="font-size:1.5rem;color:var(--neon-blue)">00:00</p>
                            </div>
                            <div class="stat-box">
                                <h3>Mejor</h3>
                                <p id="puzzleBest" style="font-size:1.5rem;color:var(--neon-pink)">-</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="puzzleShuffle" class="game-button">Mezclar</button>
                            <button id="puzzleReset" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Reiniciar</button>
                            <button id="puzzleSolve" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Resolver</button>
                        </div>
                        
                        <div class="game-feedback" id="puzzleFeedback" style="margin-top:20px;">
                            <p id="puzzleMessage">Haz clic en una pieza adyacente al espacio vacío para moverla.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initPuzzle15Game();
        }

        function initPuzzle15Game() {
            let board = [];
            let emptyIndex = 15; // Índice del espacio vacío (0-15)
            let moves = 0;
            let timer = 0;
            let timerInterval = null;
            let gameActive = false;
            let solving = false;
            
            const boardElement = document.getElementById('puzzle15Board');
            const puzzleMovesElement = document.getElementById('puzzleMoves');
            const puzzleTimerElement = document.getElementById('puzzleTimer');
            const puzzleBestElement = document.getElementById('puzzleBest');
            const puzzleMessage = document.getElementById('puzzleMessage');
            
            // Inicializar juego
            function initGame() {
                // Crear tablero ordenado
                board = [];
                for (let i = 1; i <= 15; i++) {
                    board.push(i);
                }
                board.push(0); // 0 representa el espacio vacío
                
                emptyIndex = 15;
                moves = 0;
                gameActive = false;
                solving = false;
                
                // Actualizar UI
                puzzleMovesElement.textContent = moves;
                puzzleTimerElement.textContent = '00:00';
                puzzleMessage.textContent = 'Haz clic en "Mezclar" para comenzar.';
                
                // Cargar mejor récord
                const bestMoves = localStorage.getItem('puzzle15BestMoves');
                const bestTime = localStorage.getItem('puzzle15BestTime');
                
                if (bestMoves && bestTime) {
                    puzzleBestElement.textContent = `${bestMoves} mov, ${formatTime(bestTime)}`;
                }
                
                // Renderizar tablero
                renderBoard();
                
                // Detener timer si está corriendo
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timer = 0;
                }
            }
            
            // Mezclar tablero
            function shuffleBoard() {
                // Realizar movimientos aleatorios para mezclar
                const shuffleMoves = 1000;
                
                for (let i = 0; i < shuffleMoves; i++) {
                    // Encontrar movimientos válidos
                    const validMoves = getValidMoves();
                    
                    // Elegir un movimiento aleatorio
                    if (validMoves.length > 0) {
                        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        movePiece(randomMove, false);
                    }
                }
                
                // Reiniciar contadores
                moves = 0;
                timer = 0;
                gameActive = true;
                
                puzzleMovesElement.textContent = moves;
                puzzleTimerElement.textContent = '00:00';
                puzzleMessage.textContent = '¡Comienza a resolver el rompecabezas!';
                
                // Iniciar timer
                if (timerInterval) clearInterval(timerInterval);
                startTimer();
                
                renderBoard();
            }
            
            // Obtener movimientos válidos
            function getValidMoves() {
                const validMoves = [];
                const row = Math.floor(emptyIndex / 4);
                const col = emptyIndex % 4;
                
                // Arriba
                if (row > 0) validMoves.push(emptyIndex - 4);
                // Abajo
                if (row < 3) validMoves.push(emptyIndex + 4);
                // Izquierda
                if (col > 0) validMoves.push(emptyIndex - 1);
                // Derecha
                if (col < 3) validMoves.push(emptyIndex + 1);
                
                return validMoves;
            }
            
            // Mover pieza
            function movePiece(index, countMove = true) {
                if (solving || !gameActive) return;
                
                // Verificar si el movimiento es válido
                const validMoves = getValidMoves();
                if (!validMoves.includes(index)) return;
                
                // Intercambiar pieza con espacio vacío
                [board[emptyIndex], board[index]] = [board[index], board[emptyIndex]];
                emptyIndex = index;
                
                // Contar movimiento
                if (countMove) {
                    moves++;
                    puzzleMovesElement.textContent = moves;
                }
                
                // Verificar si se resolvió
                if (checkSolved()) {
                    endGame();
                }
                
                renderBoard();
            }
            
            // Renderizar tablero
            function renderBoard() {
                boardElement.innerHTML = '';
                
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'puzzle15-cell';
                    
                    if (board[i] === 0) {
                        cell.classList.add('empty');
                        cell.textContent = '';
                    } else {
                        cell.textContent = board[i];
                        
                        // Color basado en el número
                        const hue = (board[i] * 24) % 360;
                        cell.style.background = `linear-gradient(45deg, hsl(${hue}, 100%, 50%), hsl(${hue + 20}, 100%, 30%))`;
                        cell.style.color = 'white';
                        cell.style.textShadow = '1px 1px 2px rgba(0,0,0,0.5)';
                    }
                    
                    // Solo hacer clicable si está adyacente al espacio vacío
                    if (getValidMoves().includes(i) && board[i] !== 0) {
                        cell.style.cursor = 'pointer';
                        cell.addEventListener('click', () => movePiece(i));
                    } else {
                        cell.style.cursor = 'default';
                    }
                    
                    boardElement.appendChild(cell);
                }
            }
            
            // Verificar si está resuelto
            function checkSolved() {
                for (let i = 0; i < 15; i++) {
                    if (board[i] !== i + 1) return false;
                }
                return board[15] === 0;
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    puzzleTimerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Resolver automáticamente
            function solvePuzzle() {
                if (solving || !gameActive) return;
                
                solving = true;
                puzzleMessage.textContent = 'Resolviendo...';
                
                // Detener timer
                clearInterval(timerInterval);
                
                // Ordenar tablero
                board = [];
                for (let i = 1; i <= 15; i++) {
                    board.push(i);
                }
                board.push(0);
                
                emptyIndex = 15;
                
                // Mostrar mensaje de éxito
                setTimeout(() => {
                    puzzleMessage.innerHTML = `<span style="color:var(--neon-green)">¡Rompecabezas resuelto!</span>`;
                    gameActive = false;
                    solving = false;
                    renderBoard();
                }, 500);
            }
            
            // Finalizar juego
            function endGame() {
                gameActive = false;
                clearInterval(timerInterval);
                
                puzzleMessage.innerHTML = `
                    <span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Resolviste el rompecabezas en ${moves} movimientos y ${formatTime(timer)}.
                    </span>
                `;
                
                // Guardar récord si es mejor
                const bestMoves = localStorage.getItem('puzzle15BestMoves') || Infinity;
                const bestTime = localStorage.getItem('puzzle15BestTime') || Infinity;
                
                let newRecord = false;
                
                if (moves < bestMoves || (moves == bestMoves && timer < bestTime)) {
                    localStorage.setItem('puzzle15BestMoves', moves);
                    localStorage.setItem('puzzle15BestTime', timer);
                    newRecord = true;
                }
                
                if (newRecord) {
                    puzzleBestElement.textContent = `${moves} mov, ${formatTime(timer)}`;
                    puzzleMessage.innerHTML += `
                        <p style="color:var(--neon-pink);margin-top:5px;">
                            <i class="fas fa-crown"></i> ¡Nuevo récord!
                        </p>
                    `;
                }
            }
            
            // Configurar event listeners
            document.getElementById('puzzleShuffle').addEventListener('click', shuffleBoard);
            document.getElementById('puzzleReset').addEventListener('click', initGame);
            document.getElementById('puzzleSolve').addEventListener('click', solvePuzzle);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 8: Ahorcado ====================
        function loadHangmanGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Ahorcado</h2>
                    
                    <p class="game-instructions">
                        Adivina la palabra letra por letra antes de que se complete el dibujo del ahorcado.
                        Tienes 6 intentos. ¡Buena suerte!
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="hangman-drawing">
                            <svg width="300" height="300">
                                <!-- Base -->
                                <line x1="50" y1="280" x2="150" y2="280" class="hangman-part" id="base"/>
                                <!-- Poste vertical -->
                                <line x1="100" y1="280" x2="100" y2="50" class="hangman-part" id="pole"/>
                                <!-- Travesaño superior -->
                                <line x1="100" y1="50" x2="200" y2="50" class="hangman-part" id="beam"/>
                                <!-- Cuerda -->
                                <line x1="200" y1="50" x2="200" y2="80" class="hangman-part" id="rope"/>
                                <!-- Cabeza -->
                                <circle cx="200" cy="100" r="20" class="hangman-part" id="head"/>
                                <!-- Cuerpo -->
                                <line x1="200" y1="120" x2="200" y2="200" class="hangman-part" id="body"/>
                                <!-- Brazo izquierdo -->
                                <line x1="200" y1="140" x2="160" y2="160" class="hangman-part" id="leftArm"/>
                                <!-- Brazo derecho -->
                                <line x1="200" y1="140" x2="240" y2="160" class="hangman-part" id="rightArm"/>
                                <!-- Pierna izquierda -->
                                <line x1="200" y1="200" x2="160" y2="240" class="hangman-part" id="leftLeg"/>
                                <!-- Pierna derecha -->
                                <line x1="200" y1="200" x2="240" y2="240" class="hangman-part" id="rightLeg"/>
                            </svg>
                        </div>
                        
                        <div class="hangman-word" id="hangmanWord"></div>
                        
                        <div id="hangmanKeyboard" style="margin:20px 0; max-width:600px; display:flex; flex-wrap:wrap; justify-content:center; gap:5px;"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Intentos</h3>
                                <p id="hangmanAttempts" style="font-size:1.5rem;color:var(--neon-green)">6</p>
                            </div>
                            <div class="stat-box">
                                <h3>Palabra</h3>
                                <p id="hangmanCategory" style="font-size:1.5rem;color:var(--neon-blue)">-</p>
                            </div>
                            <div class="stat-box">
                                <h3>Puntuación</h3>
                                <p id="hangmanScore" style="font-size:1.5rem;color:var(--neon-pink)">0</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="hangmanNew" class="game-button">Nueva Palabra</button>
                            <button id="hangmanHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista</button>
                            <button id="hangmanReset" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Reiniciar</button>
                        </div>
                        
                        <div class="game-feedback" id="hangmanFeedback" style="margin-top:20px;">
                            <p id="hangmanMessage">Haz clic en una letra para comenzar a adivinar.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initHangmanGame();
        }

        function initHangmanGame() {
            // Categorías y palabras
            const wordCategories = {
                animales: ['ELEFANTE', 'JIRAFA', 'DELFIN', 'TIGRE', 'LEOPARDO', 'CANGREJO', 'MARIPOSA', 'ARDILLA'],
                paises: ['ESPAÑA', 'FRANCIA', 'ITALIA', 'ALEMANIA', 'JAPON', 'CANADA', 'BRASIL', 'ARGENTINA'],
                deportes: ['FUTBOL', 'BALONCESTO', 'TENIS', 'NATACION', 'CICLISMO', 'ATLETISMO', 'VOLEIBOL', 'AJEDREZ'],
                tecnologia: ['COMPUTADORA', 'TELEFONO', 'INTERNET', 'PROGRAMACION', 'ALGORITMO', 'REDES', 'HARDWARE', 'SOFTWARE']
            };
            
            let currentWord = '';
            let currentCategory = '';
            let guessedLetters = [];
            let wrongGuesses = 0;
            let maxWrongGuesses = 6;
            let score = 0;
            let gameActive = true;
            let hintsLeft = 3;
            
            const hangmanWordElement = document.getElementById('hangmanWord');
            const hangmanKeyboardElement = document.getElementById('hangmanKeyboard');
            const hangmanAttemptsElement = document.getElementById('hangmanAttempts');
            const hangmanCategoryElement = document.getElementById('hangmanCategory');
            const hangmanScoreElement = document.getElementById('hangmanScore');
            const hangmanMessage = document.getElementById('hangmanMessage');
            const hangmanParts = document.querySelectorAll('.hangman-part');
            
            // Inicializar juego
            function initGame() {
                // Elegir categoría aleatoria
                const categories = Object.keys(wordCategories);
                currentCategory = categories[Math.floor(Math.random() * categories.length)];
                
                // Elegir palabra aleatoria de la categoría
                const words = wordCategories[currentCategory];
                currentWord = words[Math.floor(Math.random() * words.length)];
                
                // Reiniciar estado del juego
                guessedLetters = [];
                wrongGuesses = 0;
                gameActive = true;
                hintsLeft = 3;
                
                // Ocultar todas las partes del ahorcado
                hangmanParts.forEach(part => {
                    part.classList.remove('visible');
                });
                
                // Actualizar UI
                hangmanAttemptsElement.textContent = maxWrongGuesses - wrongGuesses;
                hangmanCategoryElement.textContent = currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1);
                hangmanScoreElement.textContent = score;
                hangmanMessage.textContent = `Adivina la palabra (${currentCategory}). Tienes ${maxWrongGuesses} intentos.`;
                
                // Crear teclado
                createKeyboard();
                
                // Mostrar palabra oculta
                updateWordDisplay();
            }
            
            // Crear teclado
            function createKeyboard() {
                hangmanKeyboardElement.innerHTML = '';
                
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let letter of alphabet) {
                    const key = document.createElement('button');
                    key.className = 'game-button';
                    key.style.padding = '10px 15px';
                    key.style.margin = '2px';
                    key.style.fontSize = '1.2rem';
                    key.textContent = letter;
                    
                    key.addEventListener('click', () => guessLetter(letter));
                    hangmanKeyboardElement.appendChild(key);
                }
            }
            
            // Actualizar visualización de la palabra
            function updateWordDisplay() {
                hangmanWordElement.innerHTML = '';
                
                for (let letter of currentWord) {
                    const letterElement = document.createElement('div');
                    letterElement.className = 'hangman-letter';
                    
                    if (guessedLetters.includes(letter) || letter === ' ') {
                        letterElement.textContent = letter;
                        letterElement.style.color = 'var(--neon-green)';
                    } else if (letter === '-') {
                        letterElement.textContent = '-';
                        letterElement.style.color = 'var(--neon-blue)';
                        letterElement.style.borderBottom = 'none';
                    } else {
                        letterElement.textContent = '_';
                    }
                    
                    hangmanWordElement.appendChild(letterElement);
                }
            }
            
            // Adivinar letra
            function guessLetter(letter) {
                if (!gameActive || guessedLetters.includes(letter)) return;
                
                guessedLetters.push(letter);
                
                // Verificar si la letra está en la palabra
                if (currentWord.includes(letter)) {
                    // Letra correcta
                    hangmanMessage.innerHTML = `<span style="color:var(--neon-green)">¡Correcto! La letra ${letter} está en la palabra.</span>`;
                    
                    // Verificar si se adivinó toda la palabra
                    if (checkWordGuessed()) {
                        endGame(true);
                    }
                } else {
                    // Letra incorrecta
                    wrongGuesses++;
                    hangmanMessage.innerHTML = `<span style="color:var(--neon-pink)">Incorrecto. La letra ${letter} no está en la palabra.</span>`;
                    
                    // Mostrar siguiente parte del ahorcado
                    if (wrongGuesses <= maxWrongGuesses) {
                        const partId = ['base', 'pole', 'beam', 'rope', 'head', 'body', 'leftArm', 'rightArm', 'leftLeg', 'rightLeg'][wrongGuesses - 1];
                        const part = document.getElementById(partId);
                        if (part) part.classList.add('visible');
                    }
                    
                    // Verificar si se perdió
                    if (wrongGuesses >= maxWrongGuesses) {
                        endGame(false);
                    }
                }
                
                // Actualizar UI
                hangmanAttemptsElement.textContent = maxWrongGuesses - wrongGuesses;
                updateWordDisplay();
                
                // Deshabilitar tecla
                disableKey(letter);
            }
            
            // Deshabilitar tecla
            function disableKey(letter) {
                const keys = hangmanKeyboardElement.querySelectorAll('button');
                keys.forEach(key => {
                    if (key.textContent === letter) {
                        key.disabled = true;
                        if (currentWord.includes(letter)) {
                            key.style.background = 'linear-gradient(45deg, var(--neon-green), #00aa00)';
                        } else {
                            key.style.background = 'linear-gradient(45deg, var(--neon-pink), #aa0000)';
                        }
                    }
                });
            }
            
            // Verificar si se adivinó toda la palabra
            function checkWordGuessed() {
                for (let letter of currentWord) {
                    if (letter !== ' ' && letter !== '-' && !guessedLetters.includes(letter)) {
                        return false;
                    }
                }
                return true;
            }
            
            // Dar pista
            function giveHint() {
                if (!gameActive || hintsLeft <= 0) return;
                
                // Encontrar una letra no adivinada
                const unguessedLetters = [];
                for (let letter of currentWord) {
                    if (letter !== ' ' && letter !== '-' && !guessedLetters.includes(letter) && !unguessedLetters.includes(letter)) {
                        unguessedLetters.push(letter);
                    }
                }
                
                if (unguessedLetters.length > 0) {
                    const hintLetter = unguessedLetters[Math.floor(Math.random() * unguessedLetters.length)];
                    hintsLeft--;
                    
                    // Mostrar pista
                    hangmanMessage.innerHTML = `<span style="color:var(--neon-yellow)">Pista: la palabra contiene la letra "${hintLetter}".</span>`;
                    
                    // Resaltar la letra en el teclado
                    const keys = hangmanKeyboardElement.querySelectorAll('button');
                    keys.forEach(key => {
                        if (key.textContent === hintLetter) {
                            key.style.boxShadow = '0 0 15px var(--neon-yellow)';
                            key.style.animation = 'pulse 1s infinite alternate';
                        }
                    });
                    
                    // Quitar resaltado después de 2 segundos
                    setTimeout(() => {
                        const keys = hangmanKeyboardElement.querySelectorAll('button');
                        keys.forEach(key => {
                            if (key.textContent === hintLetter) {
                                key.style.boxShadow = '';
                                key.style.animation = '';
                            }
                        });
                    }, 2000);
                }
            }
            
            // Finalizar juego
            function endGame(success) {
                gameActive = false;
                
                // Deshabilitar todas las teclas
                const keys = hangmanKeyboardElement.querySelectorAll('button');
                keys.forEach(key => {
                    key.disabled = true;
                });
                
                if (success) {
                    // Calcular puntuación
                    const wordScore = currentWord.length * 10;
                    const attemptsBonus = (maxWrongGuesses - wrongGuesses) * 5;
                    const totalScore = wordScore + attemptsBonus;
                    
                    score += totalScore;
                    
                    hangmanMessage.innerHTML = `
                        <span style="color:var(--neon-green); font-size:1.2rem;">
                            <i class="fas fa-trophy"></i> ¡Felicidades! Adivinaste la palabra: "${currentWord}".
                        </span>
                        <p style="margin-top:10px;color:var(--neon-blue)">Puntuación: +${totalScore} (Total: ${score})</p>
                    `;
                    
                    hangmanScoreElement.textContent = score;
                    
                    // Mostrar todas las letras
                    for (let letter of currentWord) {
                        if (letter !== ' ' && letter !== '-' && !guessedLetters.includes(letter)) {
                            guessedLetters.push(letter);
                        }
                    }
                    updateWordDisplay();
                } else {
                    hangmanMessage.innerHTML = `
                        <span style="color:var(--neon-pink); font-size:1.2rem;">
                            <i class="fas fa-times-circle"></i> ¡Ahorcado! La palabra era: "${currentWord}".
                        </span>
                        <p style="margin-top:10px;color:var(--neon-blue)">Intenta con una nueva palabra.</p>
                    `;
                    
                    // Mostrar todas las letras
                    for (let letter of currentWord) {
                        if (letter !== ' ' && letter !== '-') {
                            guessedLetters.push(letter);
                        }
                    }
                    updateWordDisplay();
                }
            }
            
            // Configurar event listeners
            document.getElementById('hangmanNew').addEventListener('click', initGame);
            document.getElementById('hangmanHint').addEventListener('click', giveHint);
            document.getElementById('hangmanReset').addEventListener('click', () => {
                score = 0;
                hangmanScoreElement.textContent = score;
                initGame();
            });
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 9: Conecta 4 ====================
        function loadConnect4Game(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Conecta 4</h2>
                    
                    <p class="game-instructions">
                        Conecta cuatro fichas en línea horizontal, vertical o diagonal. Tú eres 
                        <span style="color:var(--neon-green)">Verde</span> y la computadora es 
                        <span style="color:var(--neon-yellow)">Amarillo</span>. ¡Gana el primero en conectar 4!
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="connect4-board" id="connect4Board"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Turno</h3>
                                <p id="connect4Turn" style="font-size:1.5rem;color:var(--neon-green)">Tú (Verde)</p>
                            </div>
                            <div class="stat-box">
                                <h3>Resultado</h3>
                                <p id="connect4Result" style="font-size:1.5rem;color:var(--neon-blue)">En juego</p>
                            </div>
                            <div class="stat-box">
                                <h3>Récord</h3>
                                <p id="connect4Record" style="font-size:1.5rem;color:var(--neon-pink)">0-0-0</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="connect4Reset" class="game-button">Reiniciar</button>
                            <button id="connect4Undo" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Deshacer</button>
                            <button id="connect4Difficulty" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Cambiar Dificultad</button>
                        </div>
                        
                        <div class="game-feedback" id="connect4Feedback" style="margin-top:20px;">
                            <p id="connect4Message">Haz clic en una columna para colocar tu ficha.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initConnect4Game();
        }

        function initConnect4Game() {
            const rows = 6;
            const cols = 7;
            let board = [];
            let currentPlayer = 1; // 1 = jugador (verde), 2 = computadora (amarillo)
            let gameActive = true;
            let moveHistory = [];
            let difficulty = 'medium'; // 'easy', 'medium', 'hard'
            let record = {
                wins: 0,
                losses: 0,
                draws: 0
            };
            
            const boardElement = document.getElementById('connect4Board');
            const connect4TurnElement = document.getElementById('connect4Turn');
            const connect4ResultElement = document.getElementById('connect4Result');
            const connect4RecordElement = document.getElementById('connect4Record');
            const connect4Message = document.getElementById('connect4Message');
            
            // Cargar récord desde localStorage
            const savedRecord = localStorage.getItem('connect4Record');
            if (savedRecord) {
                record = JSON.parse(savedRecord);
                updateRecordDisplay();
            }
            
            // Inicializar juego
            function initGame() {
                // Crear tablero vacío
                board = [];
                for (let r = 0; r < rows; r++) {
                    board[r] = [];
                    for (let c = 0; c < cols; c++) {
                        board[r][c] = 0;
                    }
                }
                
                currentPlayer = 1;
                gameActive = true;
                moveHistory = [];
                
                // Actualizar UI
                connect4TurnElement.textContent = 'Tú (Verde)';
                connect4TurnElement.style.color = 'var(--neon-green)';
                connect4ResultElement.textContent = 'En juego';
                connect4ResultElement.style.color = 'var(--neon-blue)';
                connect4Message.textContent = 'Haz clic en una columna para colocar tu ficha.';
                
                // Renderizar tablero
                renderBoard();
            }
            
            // Renderizar tablero
            function renderBoard() {
                boardElement.innerHTML = '';
                
                // Crear encabezado de columnas
                for (let c = 0; c < cols; c++) {
                    const headerCell = document.createElement('div');
                    headerCell.style.gridColumn = c + 1;
                    headerCell.style.gridRow = 1;
                    headerCell.style.display = 'flex';
                    headerCell.style.alignItems = 'center';
                    headerCell.style.justifyContent = 'center';
                    
                    if (gameActive && currentPlayer === 1) {
                        const dropButton = document.createElement('button');
                        dropButton.textContent = '↓';
                        dropButton.style.background = 'transparent';
                        dropButton.style.border = 'none';
                        dropButton.style.color = 'var(--neon-green)';
                        dropButton.style.fontSize = '1.5rem';
                        dropButton.style.cursor = 'pointer';
                        dropButton.dataset.column = c;
                        
                        dropButton.addEventListener('click', () => makeMove(c));
                        headerCell.appendChild(dropButton);
                    }
                    
                    boardElement.appendChild(headerCell);
                }
                
                // Crear celdas del tablero
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'connect4-cell';
                        cell.style.gridColumn = c + 1;
                        cell.style.gridRow = rows - r + 1; // +1 por la fila de encabezado
                        
                        if (board[r][c] === 1) {
                            cell.classList.add('red'); // Verde para jugador
                            cell.style.background = 'radial-gradient(circle at 30% 30%, var(--neon-green), #008800)';
                        } else if (board[r][c] === 2) {
                            cell.classList.add('yellow'); // Amarillo para computadora
                            cell.style.background = 'radial-gradient(circle at 30% 30%, var(--neon-yellow), #888800)';
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // Realizar movimiento
            function makeMove(column) {
                if (!gameActive || currentPlayer !== 1) return;
                
                // Encontrar fila disponible
                let row = -1;
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r][column] === 0) {
                        row = r;
                        break;
                    }
                }
                
                if (row === -1) {
                    // Columna llena
                    connect4Message.innerHTML = `<span style="color:var(--neon-pink)">Columna llena. Elige otra columna.</span>`;
                    return;
                }
                
                // Colocar ficha
                board[row][column] = currentPlayer;
                moveHistory.push({row, column, player: currentPlayer});
                
                // Verificar si ganó
                if (checkWin(row, column, currentPlayer)) {
                    endGame('win');
                    return;
                }
                
                // Verificar empate
                if (checkDraw()) {
                    endGame('draw');
                    return;
                }
                
                // Cambiar turno a la computadora
                currentPlayer = 2;
                connect4TurnElement.textContent = 'Computadora (Amarillo)';
                connect4TurnElement.style.color = 'var(--neon-yellow)';
                connect4Message.textContent = 'La computadora está pensando...';
                
                renderBoard();
                
                // La computadora juega después de un breve retraso
                setTimeout(computerMove, 500);
            }
            
            // Movimiento de la computadora
            function computerMove() {
                if (!gameActive || currentPlayer !== 2) return;
                
                let column;
                
                if (difficulty === 'easy') {
                    // Modo fácil: movimiento aleatorio
                    const availableColumns = [];
                    for (let c = 0; c < cols; c++) {
                        if (board[0][c] === 0) {
                            availableColumns.push(c);
                        }
                    }
                    
                    if (availableColumns.length > 0) {
                        column = availableColumns[Math.floor(Math.random() * availableColumns.length)];
                    }
                } else if (difficulty === 'medium') {
                    // Modo medio: intenta ganar o bloquear
                    column = findWinningMove(2) || findWinningMove(1) || findRandomMove();
                } else {
                    // Modo difícil: algoritmo minimax simplificado
                    column = findWinningMove(2) || findWinningMove(1) || findStrategicMove() || findRandomMove();
                }
                
                if (column !== undefined) {
                    // Encontrar fila disponible
                    let row = -1;
                    for (let r = rows - 1; r >= 0; r--) {
                        if (board[r][column] === 0) {
                            row = r;
                            break;
                        }
                    }
                    
                    if (row !== -1) {
                        board[row][column] = currentPlayer;
                        moveHistory.push({row, column, player: currentPlayer});
                        
                        // Verificar si ganó
                        if (checkWin(row, column, currentPlayer)) {
                            endGame('loss');
                            return;
                        }
                        
                        // Verificar empate
                        if (checkDraw()) {
                            endGame('draw');
                            return;
                        }
                        
                        // Cambiar turno al jugador
                        currentPlayer = 1;
                        connect4TurnElement.textContent = 'Tú (Verde)';
                        connect4TurnElement.style.color = 'var(--neon-green)';
                        connect4Message.textContent = 'Tu turno. Haz clic en una columna.';
                        
                        renderBoard();
                    }
                }
            }
            
            // Encontrar movimiento ganador
            function findWinningMove(player) {
                for (let c = 0; c < cols; c++) {
                    // Encontrar fila disponible en esta columna
                    let row = -1;
                    for (let r = rows - 1; r >= 0; r--) {
                        if (board[r][c] === 0) {
                            row = r;
                            break;
                        }
                    }
                    
                    if (row !== -1) {
                        // Probar movimiento
                        board[row][c] = player;
                        
                        // Verificar si gana
                        if (checkWin(row, c, player)) {
                            // Deshacer movimiento de prueba
                            board[row][c] = 0;
                            return c;
                        }
                        
                        // Deshacer movimiento de prueba
                        board[row][c] = 0;
                    }
                }
                return null;
            }
            
            // Encontrar movimiento estratégico
            function findStrategicMove() {
                // Priorizar columnas centrales
                const centerColumns = [3, 2, 4, 1, 5, 0, 6];
                
                for (let c of centerColumns) {
                    if (board[0][c] === 0) {
                        return c;
                    }
                }
                
                return null;
            }
            
            // Movimiento aleatorio
            function findRandomMove() {
                const availableColumns = [];
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === 0) {
                        availableColumns.push(c);
                    }
                }
                
                if (availableColumns.length > 0) {
                    return availableColumns[Math.floor(Math.random() * availableColumns.length)];
                }
                
                return null;
            }
            
            // Verificar victoria
            function checkWin(row, col, player) {
                // Direcciones: horizontal, vertical, diagonal \, diagonal /
                const directions = [
                    [0, 1],  // derecha
                    [1, 0],  // abajo
                    [1, 1],  // diagonal \
                    [1, -1]  // diagonal /
                ];
                
                for (let [dr, dc] of directions) {
                    let count = 1; // Contar la ficha actual
                    
                    // Contar en dirección positiva
                    for (let i = 1; i < 4; i++) {
                        const r = row + dr * i;
                        const c = col + dc * i;
                        
                        if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] !== player) {
                            break;
                        }
                        count++;
                    }
                    
                    // Contar en dirección negativa
                    for (let i = 1; i < 4; i++) {
                        const r = row - dr * i;
                        const c = col - dc * i;
                        
                        if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] !== player) {
                            break;
                        }
                        count++;
                    }
                    
                    if (count >= 4) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Verificar empate
            function checkDraw() {
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === 0) {
                        return false;
                    }
                }
                return true;
            }
            
            // Deshacer movimiento
            function undoMove() {
                if (moveHistory.length === 0 || !gameActive) return;
                
                const lastMove = moveHistory.pop();
                board[lastMove.row][lastMove.column] = 0;
                currentPlayer = lastMove.player === 1 ? 1 : 2;
                
                // Actualizar UI
                if (currentPlayer === 1) {
                    connect4TurnElement.textContent = 'Tú (Verde)';
                    connect4TurnElement.style.color = 'var(--neon-green)';
                } else {
                    connect4TurnElement.textContent = 'Computadora (Amarillo)';
                    connect4TurnElement.style.color = 'var(--neon-yellow)';
                }
                
                connect4Message.textContent = 'Movimiento deshecho.';
                renderBoard();
            }
            
            // Cambiar dificultad
            function changeDifficulty() {
                if (difficulty === 'easy') {
                    difficulty = 'medium';
                    document.getElementById('connect4Difficulty').textContent = 'Dificultad: Media';
                } else if (difficulty === 'medium') {
                    difficulty = 'hard';
                    document.getElementById('connect4Difficulty').textContent = 'Dificultad: Difícil';
                } else {
                    difficulty = 'easy';
                    document.getElementById('connect4Difficulty').textContent = 'Dificultad: Fácil';
                }
                
                initGame();
            }
            
            // Finalizar juego
            function endGame(result) {
                gameActive = false;
                
                if (result === 'win') {
                    connect4ResultElement.textContent = '¡Ganaste!';
                    connect4ResultElement.style.color = 'var(--neon-green)';
                    connect4Message.innerHTML = `<span style="color:var(--neon-green)">¡Felicidades! Ganaste a la computadora.</span>`;
                    record.wins++;
                } else if (result === 'loss') {
                    connect4ResultElement.textContent = 'Perdiste';
                    connect4ResultElement.style.color = 'var(--neon-pink)';
                    connect4Message.innerHTML = `<span style="color:var(--neon-pink)">La computadora ganó. ¡Inténtalo de nuevo!</span>`;
                    record.losses++;
                } else {
                    connect4ResultElement.textContent = 'Empate';
                    connect4ResultElement.style.color = 'var(--neon-blue)';
                    connect4Message.innerHTML = `<span style="color:var(--neon-blue)">El juego terminó en empate.</span>`;
                    record.draws++;
                }
                
                updateRecordDisplay();
                saveRecord();
            }
            
            // Actualizar récord
            function updateRecordDisplay() {
                connect4RecordElement.textContent = `${record.wins}-${record.losses}-${record.draws}`;
            }
            
            // Guardar récord
            function saveRecord() {
                localStorage.setItem('connect4Record', JSON.stringify(record));
            }
            
            // Configurar event listeners
            document.getElementById('connect4Reset').addEventListener('click', initGame);
            document.getElementById('connect4Undo').addEventListener('click', undoMove);
            document.getElementById('connect4Difficulty').addEventListener('click', changeDifficulty);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 10: Laberinto ====================
        function loadMazeGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Laberinto</h2>
                    
                    <p class="game-instructions">
                        Encuentra la salida del laberinto. Usa las teclas de flecha o WASD para moverte.
                        <span style="color:var(--neon-green)">Verde</span> = inicio, 
                        <span style="color:var(--neon-pink)">Rosa</span> = fin.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div id="mazeContainer" style="position:relative; margin:0 auto; background:rgba(0,0,0,0.3); border-radius:8px; overflow:hidden;"></div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Tamaño</h3>
                                <p id="mazeSize" style="font-size:1.5rem;color:var(--neon-green)">15x15</p>
                            </div>
                            <div class="stat-box">
                                <h3>Movimientos</h3>
                                <p id="mazeMoves" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="mazeTimer" style="font-size:1.5rem;color:var(--neon-pink)">00:00</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="mazeNew" class="game-button">Nuevo Laberinto</button>
                            <button id="mazeSolve" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Mostrar Solución</button>
                            <button id="mazeChangeSize" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Cambiar Tamaño</button>
                        </div>
                        
                        <div class="game-feedback" id="mazeFeedback" style="margin-top:20px;">
                            <p id="mazeMessage">Usa las teclas de flecha o WASD para moverte por el laberinto.</p>
                            <p style="color:var(--text-secondary); font-size:0.9rem; margin-top:5px;">
                                Controles: Flechas ↑↓←→ o W A S D
                            </p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initMazeGame();
        }

        function initMazeGame() {
            let maze = [];
            let mazeSize = 15;
            let playerPos = {x: 1, y: 1};
            let exitPos = {x: 0, y: 0};
            let moves = 0;
            let timer = 0;
            let timerInterval = null;
            let gameActive = false;
            let solutionPath = [];
            let showingSolution = false;
            
            const mazeContainer = document.getElementById('mazeContainer');
            const mazeSizeElement = document.getElementById('mazeSize');
            const mazeMovesElement = document.getElementById('mazeMoves');
            const mazeTimerElement = document.getElementById('mazeTimer');
            const mazeMessage = document.getElementById('mazeMessage');
            
            // Inicializar juego
            function initGame() {
                // Generar laberinto
                generateMaze(mazeSize, mazeSize);
                
                // Posicionar jugador en la entrada (1,1)
                playerPos = {x: 1, y: 1};
                
                // Posicionar salida en la esquina opuesta
                exitPos = {x: mazeSize - 2, y: mazeSize - 2};
                maze[exitPos.y][exitPos.x] = 2; // 2 = salida
                
                // Reiniciar contadores
                moves = 0;
                timer = 0;
                gameActive = true;
                showingSolution = false;
                solutionPath = [];
                
                // Actualizar UI
                mazeSizeElement.textContent = `${mazeSize}x${mazeSize}`;
                mazeMovesElement.textContent = moves;
                mazeTimerElement.textContent = '00:00';
                mazeMessage.textContent = 'Usa las teclas de flecha o WASD para moverte por el laberinto.';
                
                // Renderizar laberinto
                renderMaze();
                
                // Iniciar timer
                if (timerInterval) clearInterval(timerInterval);
                startTimer();
                
                // Enfocar el contenedor del laberinto para capturar eventos de teclado
                mazeContainer.focus();
                mazeContainer.tabIndex = 0;
            }
            
            // Generar laberinto usando el algoritmo de backtracking
            function generateMaze(width, height) {
                // Inicializar laberinto lleno de paredes (1 = pared, 0 = camino)
                maze = [];
                for (let y = 0; y < height; y++) {
                    maze[y] = [];
                    for (let x = 0; x < width; x++) {
                        maze[y][x] = 1;
                    }
                }
                
                // Pila para backtracking
                const stack = [];
                
                // Posición inicial (siempre impar para estar en una celda de camino)
                const startX = 1;
                const startY = 1;
                
                // Marcar celda inicial como camino
                maze[startY][startX] = 0;
                stack.push({x: startX, y: startY});
                
                // Direcciones posibles
                const directions = [
                    {dx: 0, dy: -2}, // arriba
                    {dx: 2, dy: 0},  // derecha
                    {dx: 0, dy: 2},  // abajo
                    {dx: -2, dy: 0}  // izquierda
                ];
                
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    
                    // Obtener vecinos no visitados
                    const neighbors = [];
                    
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        
                        // Verificar si está dentro de los límites y es una pared
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            // Verificar si la celda entremedio también es una pared
                            const mx = current.x + dir.dx / 2;
                            const my = current.y + dir.dy / 2;
                            
                            if (maze[my][mx] === 1) {
                                neighbors.push({x: nx, y: ny, mx, my});
                            }
                        }
                    }
                    
                    if (neighbors.length > 0) {
                        // Elegir un vecino aleatorio
                        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Quitar pared entremedio
                        maze[randomNeighbor.my][randomNeighbor.mx] = 0;
                        
                        // Marcar vecino como camino
                        maze[randomNeighbor.y][randomNeighbor.x] = 0;
                        
                        // Añadir a la pila
                        stack.push({x: randomNeighbor.x, y: randomNeighbor.y});
                    } else {
                        // Backtrack
                        stack.pop();
                    }
                }
                
                // Asegurar entrada y salida
                maze[1][0] = 0; // Entrada
                maze[height - 2][width - 1] = 0; // Salida
            }
            
            // Renderizar laberinto
            function renderMaze() {
                mazeContainer.innerHTML = '';
                
                const cellSize = Math.min(500 / mazeSize, 30);
                mazeContainer.style.width = `${mazeSize * cellSize}px`;
                mazeContainer.style.height = `${mazeSize * cellSize}px`;
                
                for (let y = 0; y < mazeSize; y++) {
                    for (let x = 0; x < mazeSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'maze-cell';
                        cell.style.width = `${cellSize}px`;
                        cell.style.height = `${cellSize}px`;
                        cell.style.left = `${x * cellSize}px`;
                        cell.style.top = `${y * cellSize}px`;
                        
                        if (maze[y][x] === 1) {
                            cell.classList.add('maze-wall');
                            cell.style.background = 'var(--neon-blue)';
                        } else if (maze[y][x] === 2) {
                            cell.classList.add('maze-end');
                            cell.style.background = 'var(--neon-pink)';
                        } else if (x === 0 && y === 1) {
                            cell.classList.add('maze-start');
                            cell.style.background = 'var(--neon-green)';
                        } else if (showingSolution && solutionPath.some(p => p.x === x && p.y === y)) {
                            // Mostrar solución
                            cell.style.background = 'rgba(255, 255, 0, 0.5)';
                        } else {
                            cell.classList.add('maze-path');
                            cell.style.background = 'rgba(0, 0, 0, 0.2)';
                        }
                        
                        mazeContainer.appendChild(cell);
                    }
                }
                
                // Dibujar jugador
                const player = document.createElement('div');
                player.className = 'maze-player';
                player.style.width = `${cellSize * 0.8}px`;
                player.style.height = `${cellSize * 0.8}px`;
                player.style.left = `${playerPos.x * cellSize + cellSize * 0.1}px`;
                player.style.top = `${playerPos.y * cellSize + cellSize * 0.1}px`;
                player.style.background = 'var(--neon-yellow)';
                
                mazeContainer.appendChild(player);
            }
            
            // Mover jugador
            function movePlayer(dx, dy) {
                if (!gameActive) return;
                
                const newX = playerPos.x + dx;
                const newY = playerPos.y + dy;
                
                // Verificar límites y paredes
                if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize && maze[newY][newX] !== 1) {
                    playerPos.x = newX;
                    playerPos.y = newY;
                    moves++;
                    
                    mazeMovesElement.textContent = moves;
                    
                    // Verificar si llegó a la salida
                    if (playerPos.x === exitPos.x && playerPos.y === exitPos.y) {
                        endGame();
                    }
                    
                    renderMaze();
                }
            }
            
            // Mostrar solución
            function showSolution() {
                if (!gameActive || showingSolution) return;
                
                // Encontrar camino más corto usando BFS
                const queue = [{x: 1, y: 1, path: [{x: 1, y: 1}]}];
                const visited = new Set();
                visited.add('1,1');
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // Verificar si llegó a la salida
                    if (current.x === exitPos.x && current.y === exitPos.y) {
                        solutionPath = current.path;
                        showingSolution = true;
                        mazeMessage.innerHTML = `<span style="color:var(--neon-yellow)">Solución mostrada en amarillo. Sigue el camino.</span>`;
                        renderMaze();
                        return;
                    }
                    
                    // Vecinos
                    const directions = [
                        {dx: 0, dy: -1}, // arriba
                        {dx: 1, dy: 0},  // derecha
                        {dx: 0, dy: 1},  // abajo
                        {dx: -1, dy: 0}  // izquierda
                    ];
                    
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        const key = `${nx},${ny}`;
                        
                        if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && 
                            maze[ny][nx] !== 1 && !visited.has(key)) {
                            visited.add(key);
                            queue.push({
                                x: nx,
                                y: ny,
                                path: [...current.path, {x: nx, y: ny}]
                            });
                        }
                    }
                }
                
                mazeMessage.innerHTML = `<span style="color:var(--neon-pink)">No se pudo encontrar una solución.</span>`;
            }
            
            // Cambiar tamaño del laberinto
            function changeMazeSize() {
                if (mazeSize === 15) {
                    mazeSize = 20;
                } else if (mazeSize === 20) {
                    mazeSize = 25;
                } else {
                    mazeSize = 15;
                }
                
                initGame();
                mazeMessage.textContent = `Laberinto ${mazeSize}x${mazeSize} generado. ¡Buena suerte!`;
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    mazeTimerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Finalizar juego
            function endGame() {
                gameActive = false;
                clearInterval(timerInterval);
                
                mazeMessage.innerHTML = `
                    <span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Encontraste la salida en ${moves} movimientos y ${formatTime(timer)}.
                    </span>
                `;
                
                // Guardar récord si es mejor
                const bestMovesKey = `mazeBestMoves_${mazeSize}`;
                const bestTimeKey = `mazeBestTime_${mazeSize}`;
                
                const bestMoves = localStorage.getItem(bestMovesKey) || Infinity;
                const bestTime = localStorage.getItem(bestTimeKey) || Infinity;
                
                let newRecord = false;
                
                if (moves < bestMoves || (moves == bestMoves && timer < bestTime)) {
                    localStorage.setItem(bestMovesKey, moves);
                    localStorage.setItem(bestTimeKey, timer);
                    newRecord = true;
                }
                
                if (newRecord) {
                    mazeMessage.innerHTML += `
                        <p style="color:var(--neon-pink);margin-top:5px;">
                            <i class="fas fa-crown"></i> ¡Nuevo récord para laberinto ${mazeSize}x${mazeSize}!
                        </p>
                    `;
                }
            }
            
            // Configurar event listeners
            document.getElementById('mazeNew').addEventListener('click', initGame);
            document.getElementById('mazeSolve').addEventListener('click', showSolution);
            document.getElementById('mazeChangeSize').addEventListener('click', changeMazeSize);
            
            // Manejar eventos de teclado
            mazeContainer.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer(0, -1);
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        movePlayer(0, 1);
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer(-1, 0);
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer(1, 0);
                        e.preventDefault();
                        break;
                }
            });
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 11: Criptograma ====================
        function loadCryptogramGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Criptograma</h2>
                    
                    <p class="game-instructions">
                        Descifra el mensaje codificado. Cada letra ha sido sustituida por otra.
                        Usa las pistas de frecuencia de letras y patrones de palabras para resolverlo.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="cryptogram-container">
                            <div id="cryptogramMessage" style="font-size:1.2rem; line-height:2; margin:20px 0; min-height:100px;"></div>
                            
                            <div class="cryptogram-keyboard" id="cryptogramKeyboard"></div>
                            
                            <div id="cryptogramMapping" style="margin:20px 0; padding:15px; background:rgba(0,255,255,0.1); border-radius:8px; border:1px solid var(--neon-blue);">
                                <h3 style="color:var(--neon-green); margin-bottom:10px;">Tu Decodificación</h3>
                                <div id="mappingDisplay" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px;"></div>
                            </div>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Pistas</h3>
                                <p id="cryptogramHints" style="font-size:1.5rem;color:var(--neon-green)">3</p>
                            </div>
                            <div class="stat-box">
                                <h3>Intentos</h3>
                                <p id="cryptogramAttempts" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Completado</h3>
                                <p id="cryptogramProgress" style="font-size:1.5rem;color:var(--neon-pink)">0%</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="cryptogramNew" class="game-button">Nuevo Criptograma</button>
                            <button id="cryptogramHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista</button>
                            <button id="cryptogramCheck" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Comprobar</button>
                            <button id="cryptogramReset" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #ff5500)">Reiniciar</button>
                        </div>
                        
                        <div class="game-feedback" id="cryptogramFeedback" style="margin-top:20px;">
                            <p id="cryptogramMessageText">Haz clic en una letra del mensaje y luego en una letra del teclado para sustituirla.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initCryptogramGame();
        }

        function initCryptogramGame() {
            // Frases para criptogramas
            const phrases = [
                "EL CONOCIMIENTO ES PODER",
                "LA PRACTICA HACE AL MAESTRO",
                "MAS VALE TARDE QUE NUNCA",
                "EN BOCA CERRADA NO ENTRAN MOSCAS",
                "A QUIEN MADRUGA DIOS LE AYUDA",
                "NO HAY MAL QUE POR BIEN NO VENGA",
                "MAS VALE PREVENIR QUE CURAR",
                "CAMARON QUE SE DUERME SE LO LLEVA LA CORRIENTE",
                "EL QUE NO ARRIESGA NO GANA",
                "A DIOS ROGANDO Y CON EL MAZO DANDO"
            ];
            
            let currentPhrase = '';
            let encodedPhrase = '';
            let mapping = {}; // Mapeo original codificado -> real
            let userMapping = {}; // Mapeo del usuario codificado -> supuesta
            let selectedLetter = '';
            let hints = 3;
            let attempts = 0;
            let solved = false;
            
            const cryptogramMessage = document.getElementById('cryptogramMessage');
            const cryptogramKeyboard = document.getElementById('cryptogramKeyboard');
            const mappingDisplay = document.getElementById('mappingDisplay');
            const cryptogramHintsElement = document.getElementById('cryptogramHints');
            const cryptogramAttemptsElement = document.getElementById('cryptogramAttempts');
            const cryptogramProgressElement = document.getElementById('cryptogramProgress');
            const cryptogramMessageText = document.getElementById('cryptogramMessageText');
            
            // Inicializar juego
            function initGame() {
                // Elegir frase aleatoria
                currentPhrase = phrases[Math.floor(Math.random() * phrases.length)];
                
                // Crear mapeo de sustitución
                createSubstitutionMapping();
                
                // Codificar frase
                encodedPhrase = encodePhrase(currentPhrase);
                
                // Reiniciar estado del usuario
                userMapping = {};
                selectedLetter = '';
                hints = 3;
                attempts = 0;
                solved = false;
                
                // Actualizar UI
                cryptogramHintsElement.textContent = hints;
                cryptogramAttemptsElement.textContent = attempts;
                updateProgress();
                cryptogramMessageText.textContent = 'Haz clic en una letra del mensaje y luego en una letra del teclado para sustituirla.';
                
                // Crear mensaje codificado
                createEncodedMessage();
                
                // Crear teclado
                createKeyboard();
                
                // Crear display de mapeo
                updateMappingDisplay();
            }
            
            // Crear mapeo de sustitución
            function createSubstitutionMapping() {
                // Alfabeto
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                // Crear lista de letras aleatorias
                let shuffled = alphabet.split('').sort(() => Math.random() - 0.5);
                
                // Crear mapeo
                mapping = {};
                for (let i = 0; i < alphabet.length; i++) {
                    mapping[alphabet[i]] = shuffled[i];
                }
            }
            
            // Codificar frase
            function encodePhrase(phrase) {
                let encoded = '';
                
                for (let char of phrase) {
                    if (char >= 'A' && char <= 'Z') {
                        encoded += mapping[char];
                    } else {
                        encoded += char;
                    }
                }
                
                return encoded;
            }
            
            // Crear mensaje codificado
            function createEncodedMessage() {
                cryptogramMessage.innerHTML = '';
                
                for (let i = 0; i < encodedPhrase.length; i++) {
                    const char = encodedPhrase[i];
                    const span = document.createElement('span');
                    
                    if (char === ' ') {
                        span.className = 'cryptogram-letter space';
                        span.innerHTML = '&nbsp;';
                    } else {
                        span.className = 'cryptogram-letter';
                        span.textContent = char;
                        span.dataset.original = char;
                        
                        // Si el usuario ha asignado esta letra
                        if (userMapping[char]) {
                            span.style.color = 'var(--neon-green)';
                            span.title = `${char} → ${userMapping[char]}`;
                        }
                        
                        // Resaltar si está seleccionada
                        if (selectedLetter === char) {
                            span.style.background = 'rgba(0, 255, 255, 0.3)';
                            span.style.borderRadius = '5px';
                            span.style.padding = '2px 5px';
                        }
                        
                        span.addEventListener('click', () => selectLetter(char));
                    }
                    
                    cryptogramMessage.appendChild(span);
                }
            }
            
            // Crear teclado
            function createKeyboard() {
                cryptogramKeyboard.innerHTML = '';
                
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let letter of alphabet) {
                    const key = document.createElement('div');
                    key.className = 'cryptogram-key';
                    key.textContent = letter;
                    key.dataset.letter = letter;
                    
                    // Verificar si ya se usó esta letra
                    const usedAsValue = Object.values(userMapping).includes(letter);
                    if (usedAsValue) {
                        key.classList.add('used');
                    }
                    
                    key.addEventListener('click', () => assignLetter(letter));
                    cryptogramKeyboard.appendChild(key);
                }
            }
            
            // Seleccionar letra del mensaje
            function selectLetter(letter) {
                if (solved) return;
                
                selectedLetter = letter;
                cryptogramMessageText.textContent = `Letra "${letter}" seleccionada. Ahora haz clic en una letra del teclado para asignarla.`;
                createEncodedMessage();
            }
            
            // Asignar letra
            function assignLetter(assignedLetter) {
                if (!selectedLetter || solved) return;
                
                // Verificar si la letra ya está asignada a otra
                for (const [encoded, decoded] of Object.entries(userMapping)) {
                    if (decoded === assignedLetter && encoded !== selectedLetter) {
                        cryptogramMessageText.innerHTML = `<span style="color:var(--neon-pink)">La letra "${assignedLetter}" ya está asignada a "${encoded}".</span>`;
                        return;
                    }
                }
                
                // Asignar
                userMapping[selectedLetter] = assignedLetter;
                attempts++;
                
                cryptogramAttemptsElement.textContent = attempts;
                updateProgress();
                cryptogramMessageText.innerHTML = `<span style="color:var(--neon-green)">"${selectedLetter}" asignada como "${assignedLetter}".</span>`;
                
                // Actualizar displays
                createEncodedMessage();
                createKeyboard();
                updateMappingDisplay();
                
                // Verificar si se resolvió
                if (checkSolution()) {
                    endGame();
                }
                
                selectedLetter = '';
            }
            
            // Actualizar display de mapeo
            function updateMappingDisplay() {
                mappingDisplay.innerHTML = '';
                
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let letter of alphabet) {
                    const mappingItem = document.createElement('div');
                    mappingItem.style.display = 'flex';
                    mappingItem.style.alignItems = 'center';
                    mappingItem.style.gap = '5px';
                    mappingItem.style.margin = '5px';
                    
                    const encodedSpan = document.createElement('span');
                    encodedSpan.textContent = letter;
                    encodedSpan.style.color = 'var(--neon-blue)';
                    encodedSpan.style.fontWeight = 'bold';
                    
                    const arrowSpan = document.createElement('span');
                    arrowSpan.textContent = '→';
                    arrowSpan.style.color = 'var(--text-secondary)';
                    
                    const decodedSpan = document.createElement('span');
                    
                    if (userMapping[letter]) {
                        decodedSpan.textContent = userMapping[letter];
                        decodedSpan.style.color = 'var(--neon-green)';
                        decodedSpan.style.fontWeight = 'bold';
                    } else {
                        decodedSpan.textContent = '?';
                        decodedSpan.style.color = 'var(--neon-pink)';
                    }
                    
                    mappingItem.appendChild(encodedSpan);
                    mappingItem.appendChild(arrowSpan);
                    mappingItem.appendChild(decodedSpan);
                    mappingDisplay.appendChild(mappingItem);
                }
            }
            
            // Dar pista
            function giveHint() {
                if (hints <= 0 || solved) return;
                
                // Encontrar una letra no asignada
                const unassignedLetters = [];
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                for (let letter of alphabet) {
                    if (mapping[letter] && !userMapping[letter]) {
                        unassignedLetters.push(letter);
                    }
                }
                
                if (unassignedLetters.length > 0) {
                    // Elegir letra aleatoria
                    const randomLetter = unassignedLetters[Math.floor(Math.random() * unassignedLetters.length)];
                    
                    // Asignar automáticamente
                    userMapping[randomLetter] = mapping[randomLetter];
                    hints--;
                    attempts++;
                    
                    cryptogramHintsElement.textContent = hints;
                    cryptogramAttemptsElement.textContent = attempts;
                    updateProgress();
                    
                    cryptogramMessageText.innerHTML = `<span style="color:var(--neon-yellow)">Pista: "${randomLetter}" = "${mapping[randomLetter]}".</span>`;
                    
                    // Actualizar displays
                    createEncodedMessage();
                    createKeyboard();
                    updateMappingDisplay();
                    
                    // Verificar si se resolvió
                    if (checkSolution()) {
                        endGame();
                    }
                }
            }
            
            // Comprobar solución
            function checkSolution() {
                // Verificar si todas las letras están asignadas
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let allAssigned = true;
                
                for (let letter of alphabet) {
                    if (currentPhrase.includes(letter) && !userMapping[mapping[letter]]) {
                        allAssigned = false;
                        break;
                    }
                }
                
                if (!allAssigned) return false;
                
                // Verificar si todas las asignaciones son correctas
                for (const [encoded, userDecoded] of Object.entries(userMapping)) {
                    // Encontrar qué letra original se codificó como 'encoded'
                    let originalLetter = '';
                    for (const [orig, enc] of Object.entries(mapping)) {
                        if (enc === encoded) {
                            originalLetter = orig;
                            break;
                        }
                    }
                    
                    if (userDecoded !== originalLetter) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Actualizar progreso
            function updateProgress() {
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let assignedCount = 0;
                let totalRelevant = 0;
                
                // Contar letras relevantes en la frase
                const relevantLetters = new Set();
                for (let char of currentPhrase) {
                    if (char >= 'A' && char <= 'Z') {
                        relevantLetters.add(mapping[char]);
                    }
                }
                
                totalRelevant = relevantLetters.size;
                
                // Contar asignaciones correctas
                for (let letter of relevantLetters) {
                    if (userMapping[letter] === mapping[letter]) {
                        assignedCount++;
                    }
                }
                
                const progress = totalRelevant > 0 ? Math.round((assignedCount / totalRelevant) * 100) : 0;
                cryptogramProgressElement.textContent = `${progress}%`;
            }
            
            // Finalizar juego
            function endGame() {
                solved = true;
                
                cryptogramMessageText.innerHTML = `
                    <span style="color:var(--neon-green); font-size:1.2rem;">
                        <i class="fas fa-trophy"></i> ¡Felicidades! Descifraste el criptograma: "${currentPhrase}".
                    </span>
                    <p style="margin-top:10px;color:var(--neon-blue)">Lo resolviste en ${attempts} intentos usando ${3 - hints} pistas.</p>
                `;
                
                // Mostrar solución completa
                for (const [encoded, decoded] of Object.entries(mapping)) {
                    userMapping[encoded] = decoded;
                }
                
                createEncodedMessage();
                createKeyboard();
                updateMappingDisplay();
            }
            
            // Configurar event listeners
            document.getElementById('cryptogramNew').addEventListener('click', initGame);
            document.getElementById('cryptogramHint').addEventListener('click', giveHint);
            document.getElementById('cryptogramCheck').addEventListener('click', () => {
                if (solved) return;
                
                if (checkSolution()) {
                    endGame();
                } else {
                    cryptogramMessageText.innerHTML = `<span style="color:var(--neon-pink)">Aún no es correcto. Sigue intentando.</span>`;
                }
            });
            document.getElementById('cryptogramReset').addEventListener('click', () => {
                userMapping = {};
                selectedLetter = '';
                attempts = 0;
                
                cryptogramAttemptsElement.textContent = attempts;
                updateProgress();
                cryptogramMessageText.textContent = 'Reiniciado. Haz clic en una letra del mensaje y luego en una letra del teclado para sustituirla.';
                
                createEncodedMessage();
                createKeyboard();
                updateMappingDisplay();
            });
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 12: Mastermind ====================
        function loadMastermindGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Mastermind</h2>
                    
                    <p class="game-instructions">
                        Adivina la combinación secreta de 4 colores en 10 intentos.
                        Después de cada intento, recibirás pistas:
                        <span style="color:var(--neon-green)">●</span> = color correcto en posición correcta,
                        <span style="color:var(--neon-pink)">○</span> = color correcto en posición incorrecta.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="mastermind-board" id="mastermindBoard"></div>
                        
                        <div style="margin:20px 0;">
                            <h3 style="color:var(--neon-blue); margin-bottom:10px;">Colores Disponibles</h3>
                            <div id="colorPalette" style="display:flex; justify-content:center; gap:10px; margin-bottom:20px;"></div>
                            
                            <div id="currentGuess" style="display:flex; justify-content:center; gap:10px; margin:20px 0;"></div>
                            
                            <button id="submitGuess" class="game-button" style="margin-bottom:20px;">Comprobar Intento</button>
                            <button id="clearGuess" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00); margin-left:10px;">Limpiar</button>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Intentos</h3>
                                <p id="attemptsLeft" style="font-size:1.5rem;color:var(--neon-green)">10</p>
                            </div>
                            <div class="stat-box">
                                <h3>Dificultad</h3>
                                <p id="mastermindDifficulty" style="font-size:1.5rem;color:var(--neon-blue)">Normal</p>
                            </div>
                            <div class="stat-box">
                                <h3>Mejor</h3>
                                <p id="mastermindBest" style="font-size:1.5rem;color:var(--neon-pink)">-</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="mastermindNew" class="game-button">Nuevo Juego</button>
                            <button id="mastermindHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista</button>
                            <button id="changeDifficulty" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Cambiar Dificultad</button>
                        </div>
                        
                        <div class="game-feedback" id="mastermindFeedback" style="margin-top:20px;">
                            <p id="mastermindMessage">Selecciona 4 colores y haz clic en "Comprobar Intento".</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initMastermindGame();
        }

        function initMastermindGame() {
            // Colores disponibles
            const colors = [
                {name: 'Rojo', value: '#ff0000'},
                {name: 'Verde', value: '#00ff00'},
                {name: 'Azul', value: '#0000ff'},
                {name: 'Amarillo', value: '#ffff00'},
                {name: 'Naranja', value: '#ff8800'},
                {name: 'Rosa', value: '#ff00ff'},
                {name: 'Morado', value: '#8800ff'},
                {name: 'Cian', value: '#00ffff'}
            ];
            
            let secretCode = [];
            let currentGuess = [];
            let attempts = 0;
            let maxAttempts = 10;
            let gameActive = true;
            let difficulty = 'normal'; // 'easy', 'normal', 'hard'
            let hintsLeft = 3;
            let gameHistory = [];
            
            const mastermindBoard = document.getElementById('mastermindBoard');
            const colorPalette = document.getElementById('colorPalette');
            const currentGuessElement = document.getElementById('currentGuess');
            const attemptsLeftElement = document.getElementById('attemptsLeft');
            const mastermindDifficultyElement = document.getElementById('mastermindDifficulty');
            const mastermindBestElement = document.getElementById('mastermindBest');
            const mastermindMessage = document.getElementById('mastermindMessage');
            
            // Cargar mejor puntuación
            const bestScore = localStorage.getItem('mastermindBestScore');
            if (bestScore) {
                mastermindBestElement.textContent = bestScore;
            }
            
            // Inicializar juego
            function initGame() {
                // Generar código secreto
                generateSecretCode();
                
                // Reiniciar estado del juego
                currentGuess = [];
                attempts = 0;
                gameActive = true;
                hintsLeft = 3;
                gameHistory = [];
                
                // Actualizar UI
                attemptsLeftElement.textContent = maxAttempts - attempts;
                mastermindDifficultyElement.textContent = 
                    difficulty === 'easy' ? 'Fácil' : difficulty === 'hard' ? 'Difícil' : 'Normal';
                mastermindMessage.textContent = 'Selecciona 4 colores y haz clic en "Comprobar Intento".';
                
                // Crear paleta de colores
                createColorPalette();
                
                // Crear intento actual
                createCurrentGuess();
                
                // Limpiar tablero
                mastermindBoard.innerHTML = '';
                
                // Crear filas de intentos
                for (let i = 0; i < maxAttempts; i++) {
                    const row = document.createElement('div');
                    row.className = 'mastermind-row';
                    row.id = `row-${i}`;
                    
                    // Espacio para el intento
                    const guessDiv = document.createElement('div');
                    guessDiv.className = 'mastermind-pegs';
                    guessDiv.id = `guess-${i}`;
                    guessDiv.style.display = 'flex';
                    guessDiv.style.gap = '5px';
                    
                    // Espacio para la retroalimentación
                    const feedbackDiv = document.createElement('div');
                    feedbackDiv.className = 'mastermind-feedback';
                    feedbackDiv.id = `feedback-${i}`;
                    feedbackDiv.style.display = 'flex';
                    feedbackDiv.style.gap = '3px';
                    feedbackDiv.style.flexWrap = 'wrap';
                    feedbackDiv.style.width = '40px';
                    
                    row.appendChild(guessDiv);
                    row.appendChild(feedbackDiv);
                    mastermindBoard.appendChild(row);
                }
            }
            
            // Generar código secreto
            function generateSecretCode() {
                secretCode = [];
                
                // Número de colores según la dificultad
                let numColors;
                let allowDuplicates;
                
                switch(difficulty) {
                    case 'easy':
                        numColors = 4; // 4 colores de 4 posibles
                        allowDuplicates = false;
                        maxAttempts = 12;
                        break;
                    case 'hard':
                        numColors = 5; // 5 colores de 8 posibles
                        allowDuplicates = true;
                        maxAttempts = 8;
                        break;
                    default: // normal
                        numColors = 4; // 4 colores de 6 posibles
                        allowDuplicates = false;
                        maxAttempts = 10;
                }
                
                // Seleccionar colores disponibles según dificultad
                const availableColors = difficulty === 'easy' ? 
                    colors.slice(0, 4) : difficulty === 'normal' ? 
                    colors.slice(0, 6) : colors;
                
                // Generar código
                while (secretCode.length < numColors) {
                    const randomColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                    
                    if (!allowDuplicates && secretCode.includes(randomColor)) {
                        continue;
                    }
                    
                    secretCode.push(randomColor);
                }
            }
            
            // Crear paleta de colores
            function createColorPalette() {
                colorPalette.innerHTML = '';
                
                // Colores disponibles según dificultad
                const availableColors = difficulty === 'easy' ? 
                    colors.slice(0, 4) : difficulty === 'normal' ? 
                    colors.slice(0, 6) : colors;
                
                availableColors.forEach(color => {
                    const colorButton = document.createElement('div');
                    colorButton.className = 'mastermind-peg';
                    colorButton.style.background = color.value;
                    colorButton.title = color.name;
                    colorButton.dataset.color = JSON.stringify(color);
                    
                    colorButton.addEventListener('click', () => addColorToGuess(color));
                    colorPalette.appendChild(colorButton);
                });
            }
            
            // Crear intento actual
            function createCurrentGuess() {
                currentGuessElement.innerHTML = '';
                
                // Número de posiciones según dificultad
                const numPositions = difficulty === 'hard' ? 5 : 4;
                
                for (let i = 0; i < numPositions; i++) {
                    const pegSlot = document.createElement('div');
                    pegSlot.className = 'mastermind-peg';
                    pegSlot.id = `current-peg-${i}`;
                    pegSlot.style.background = 'rgba(255, 255, 255, 0.1)';
                    pegSlot.style.border = '2px dashed var(--neon-blue)';
                    pegSlot.style.cursor = 'pointer';
                    
                    if (currentGuess[i]) {
                        pegSlot.style.background = currentGuess[i].value;
                        pegSlot.style.border = '2px solid white';
                    }
                    
                    pegSlot.addEventListener('click', () => removeColorFromGuess(i));
                    currentGuessElement.appendChild(pegSlot);
                }
            }
            
            // Añadir color al intento actual
            function addColorToGuess(color) {
                if (!gameActive || currentGuess.length >= (difficulty === 'hard' ? 5 : 4)) return;
                
                currentGuess.push(color);
                createCurrentGuess();
                mastermindMessage.textContent = `${currentGuess.length}/4 colores seleccionados.`;
            }
            
            // Eliminar color del intento actual
            function removeColorFromGuess(index) {
                if (!gameActive || index >= currentGuess.length) return;
                
                currentGuess.splice(index, 1);
                createCurrentGuess();
                mastermindMessage.textContent = `${currentGuess.length}/4 colores seleccionados.`;
            }
            
            // Comprobar intento
            function checkGuess() {
                if (!gameActive) return;
                
                // Verificar que el intento esté completo
                const requiredLength = difficulty === 'hard' ? 5 : 4;
                if (currentGuess.length < requiredLength) {
                    mastermindMessage.innerHTML = `<span style="color:var(--neon-pink)">Selecciona ${requiredLength} colores primero.</span>`;
                    return;
                }
                
                attempts++;
                attemptsLeftElement.textContent = maxAttempts - attempts;
                
                // Calcular retroalimentación
                const feedback = calculateFeedback(currentGuess);
                
                // Guardar en historial
                gameHistory.push({
                    guess: [...currentGuess],
                    feedback: feedback
                });
                
                // Mostrar intento en el tablero
                displayGuess(attempts - 1, currentGuess, feedback);
                
                // Verificar si se ganó
                if (feedback.correct === requiredLength) {
                    endGame(true);
                    return;
                }
                
                // Verificar si se perdieron todos los intentos
                if (attempts >= maxAttempts) {
                    endGame(false);
                    return;
                }
                
                // Limpiar intento actual para el siguiente
                currentGuess = [];
                createCurrentGuess();
                mastermindMessage.textContent = `Intento ${attempts}/${maxAttempts}. Selecciona ${requiredLength} colores.`;
            }
            
            // Calcular retroalimentación
            function calculateFeedback(guess) {
                let correct = 0;
                let misplaced = 0;
                
                // Copias para no modificar los originales
                const secretCopy = [...secretCode];
                const guessCopy = [...guess];
                
                // Primero contar correctos en posición correcta
                for (let i = 0; i < secretCopy.length; i++) {
                    if (guessCopy[i] && secretCopy[i].value === guessCopy[i].value) {
                        correct++;
                        secretCopy[i] = null;
                        guessCopy[i] = null;
                    }
                }
                
                // Luego contar correctos en posición incorrecta
                for (let i = 0; i < secretCopy.length; i++) {
                    if (guessCopy[i]) {
                        for (let j = 0; j < secretCopy.length; j++) {
                            if (secretCopy[j] && secretCopy[j].value === guessCopy[i].value) {
                                misplaced++;
                                secretCopy[j] = null;
                                break;
                            }
                        }
                    }
                }
                
                return {correct, misplaced};
            }
            
            // Mostrar intento en el tablero
            function displayGuess(rowIndex, guess, feedback) {
                const guessDiv = document.getElementById(`guess-${rowIndex}`);
                const feedbackDiv = document.getElementById(`feedback-${rowIndex}`);
                
                // Mostrar intento
                guessDiv.innerHTML = '';
                guess.forEach(color => {
                    const peg = document.createElement('div');
                    peg.className = 'mastermind-peg';
                    peg.style.background = color.value;
                    peg.style.width = '30px';
                    peg.style.height = '30px';
                    guessDiv.appendChild(peg);
                });
                
                // Mostrar retroalimentación
                feedbackDiv.innerHTML = '';
                
                // Pines correctos (negros)
                for (let i = 0; i < feedback.correct; i++) {
                    const pin = document.createElement('div');
                    pin.className = 'mastermind-feedback-peg';
                    pin.style.background = 'black';
                    feedbackDiv.appendChild(pin);
                }
                
                // Pines desplazados (blancos)
                for (let i = 0; i < feedback.misplaced; i++) {
                    const pin = document.createElement('div');
                    pin.className = 'mastermind-feedback-peg';
                    pin.style.background = 'white';
                    feedbackDiv.appendChild(pin);
                }
            }
            
            // Dar pista
            function giveHint() {
                if (!gameActive || hintsLeft <= 0) return;
                
                // Encontrar una posición no adivinada
                const lastGuess = gameHistory[gameHistory.length - 1];
                let hintIndex = -1;
                let hintColor = null;
                
                if (lastGuess) {
                    // Buscar una posición donde el color sea incorrecto
                    for (let i = 0; i < secretCode.length; i++) {
                        if (!lastGuess.guess[i] || lastGuess.guess[i].value !== secretCode[i].value) {
                            hintIndex = i;
                            hintColor = secretCode[i];
                            break;
                        }
                    }
                } else {
                    // Primer intento, dar cualquier posición
                    hintIndex = Math.floor(Math.random() * secretCode.length);
                    hintColor = secretCode[hintIndex];
                }
                
                if (hintIndex !== -1) {
                    hintsLeft--;
                    mastermindMessage.innerHTML = `<span style="color:var(--neon-yellow)">Pista: La posición ${hintIndex + 1} es ${hintColor.name}.</span>`;
                }
            }
            
            // Cambiar dificultad
            function changeDifficulty() {
                if (difficulty === 'easy') {
                    difficulty = 'normal';
                } else if (difficulty === 'normal') {
                    difficulty = 'hard';
                } else {
                    difficulty = 'easy';
                }
                
                initGame();
            }
            
            // Finalizar juego
            function endGame(success) {
                gameActive = false;
                
                if (success) {
                    mastermindMessage.innerHTML = `
                        <span style="color:var(--neon-green); font-size:1.2rem;">
                            <i class="fas fa-trophy"></i> ¡Felicidades! Descifraste el código en ${attempts} intentos.
                        </span>
                    `;
                    
                    // Guardar récord si es mejor
                    const bestScore = localStorage.getItem('mastermindBestScore') || Infinity;
                    
                    if (attempts < bestScore) {
                        localStorage.setItem('mastermindBestScore', attempts);
                        mastermindBestElement.textContent = attempts;
                        mastermindMessage.innerHTML += `
                            <p style="color:var(--neon-pink);margin-top:5px;">
                                <i class="fas fa-crown"></i> ¡Nuevo récord!
                            </p>
                        `;
                    }
                } else {
                    // Mostrar código secreto
                    let codeString = '';
                    secretCode.forEach(color => {
                        codeString += `<div style="display:inline-block; width:20px; height:20px; background:${color.value}; margin:0 2px; border-radius:50%;"></div>`;
                    });
                    
                    mastermindMessage.innerHTML = `
                        <span style="color:var(--neon-pink); font-size:1.2rem;">
                            <i class="fas fa-times-circle"></i> ¡Se acabaron los intentos! El código era:
                        </span>
                        <div style="margin-top:10px;">${codeString}</div>
                    `;
                }
            }
            
            // Configurar event listeners
            document.getElementById('submitGuess').addEventListener('click', checkGuess);
            document.getElementById('clearGuess').addEventListener('click', () => {
                if (gameActive) {
                    currentGuess = [];
                    createCurrentGuess();
                    mastermindMessage.textContent = 'Intento limpiado. Selecciona 4 colores.';
                }
            });
            document.getElementById('mastermindNew').addEventListener('click', initGame);
            document.getElementById('mastermindHint').addEventListener('click', giveHint);
            document.getElementById('changeDifficulty').addEventListener('click', changeDifficulty);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 13: Juego de la Vida ====================
        function loadLifeGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Juego de la Vida</h2>
                    
                    <p class="game-instructions">
                        El Juego de la Vida de Conway es un autómata celular. Cada celda vive o muere según estas reglas:<br>
                        1. Una celda viva con menos de 2 vecinos vivos muere (soledad).<br>
                        2. Una celda viva con 2 o 3 vecinos vivos sobrevive.<br>
                        3. Una celda viva con más de 3 vecinos vivos muere (sobrepoblación).<br>
                        4. Una celda muerta con exactamente 3 vecinos vivos nace (reproducción).
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="life-board" id="lifeBoard"></div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="lifeStart" class="game-button">Iniciar</button>
                            <button id="lifePause" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pausar</button>
                            <button id="lifeStep" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Paso</button>
                            <button id="lifeClear" class="game-button" style="background:linear-gradient(45deg, #ff0000, #ff5500)">Limpiar</button>
                            <button id="lifeRandom" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #8800ff)">Aleatorio</button>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Generación</h3>
                                <p id="generationCount" style="font-size:1.5rem;color:var(--neon-green)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Células Vivas</h3>
                                <p id="liveCells" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Velocidad</h3>
                                <p id="simulationSpeed" style="font-size:1.5rem;color:var(--neon-pink)">Media</p>
                            </div>
                        </div>
                        
                        <div style="margin-top:20px;">
                            <h3 style="color:var(--neon-yellow); margin-bottom:10px;">Patrones Predefinidos</h3>
                            <div id="lifePatterns" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-bottom:20px;">
                                <button class="game-button" data-pattern="glider" style="padding:8px 15px; font-size:0.9rem;">Planeador</button>
                                <button class="game-button" data-pattern="blinker" style="padding:8px 15px; font-size:0.9rem;">Parpadeante</button>
                                <button class="game-button" data-pattern="gliderGun" style="padding:8px 15px; font-size:0.9rem;">Pistola</button>
                                <button class="game-button" data-pattern="pulsar" style="padding:8px 15px; font-size:0.9rem;">Pulsar</button>
                                <button class="game-button" data-pattern="random" style="padding:8px 15px; font-size:0.9rem;">Aleatorio</button>
                            </div>
                            
                            <div>
                                <label style="color:var(--text-secondary); margin-right:10px;">Velocidad:</label>
                                <input type="range" id="speedSlider" min="1" max="10" value="5" style="width:200px; vertical-align:middle;">
                            </div>
                        </div>
                        
                        <div class="game-feedback" id="lifeFeedback" style="margin-top:20px;">
                            <p id="lifeMessage">Haz clic en las celdas para activarlas/desactivarlas, luego haz clic en "Iniciar".</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initLifeGame();
        }

        function initLifeGame() {
            const rows = 30;
            const cols = 40;
            let grid = [];
            let nextGrid = [];
            let generation = 0;
            let isRunning = false;
            let simulationInterval = null;
            let speed = 5; // 1-10, donde 10 es más rápido
            
            const lifeBoard = document.getElementById('lifeBoard');
            const generationCountElement = document.getElementById('generationCount');
            const liveCellsElement = document.getElementById('liveCells');
            const simulationSpeedElement = document.getElementById('simulationSpeed');
            const lifeMessage = document.getElementById('lifeMessage');
            const speedSlider = document.getElementById('speedSlider');
            
            // Inicializar juego
            function initGame() {
                // Crear grids vacíos
                grid = [];
                nextGrid = [];
                
                for (let r = 0; r < rows; r++) {
                    grid[r] = [];
                    nextGrid[r] = [];
                    for (let c = 0; c < cols; c++) {
                        grid[r][c] = 0;
                        nextGrid[r][c] = 0;
                    }
                }
                
                generation = 0;
                isRunning = false;
                
                // Actualizar UI
                generationCountElement.textContent = generation;
                updateLiveCellsCount();
                simulationSpeedElement.textContent = getSpeedName();
                lifeMessage.textContent = 'Haz clic en las celdas para activarlas/desactivarlas, luego haz clic en "Iniciar".';
                
                // Detener simulación si está corriendo
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                
                // Renderizar grid
                renderGrid();
            }
            
            // Renderizar grid
            function renderGrid() {
                lifeBoard.innerHTML = '';
                lifeBoard.style.gridTemplateColumns = `repeat(${cols}, 20px)`;
                lifeBoard.style.gridTemplateRows = `repeat(${rows}, 20px)`;
                lifeBoard.style.width = `${cols * 20}px`;
                lifeBoard.style.height = `${rows * 20}px`;
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'life-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        if (grid[r][c] === 1) {
                            cell.classList.add('alive');
                        }
                        
                        cell.addEventListener('click', () => toggleCell(r, c));
                        lifeBoard.appendChild(cell);
                    }
                }
            }
            
            // Alternar celda
            function toggleCell(row, col) {
                if (isRunning) return;
                
                grid[row][col] = grid[row][col] === 0 ? 1 : 0;
                renderGrid();
                updateLiveCellsCount();
            }
            
            // Actualizar conteo de células vivas
            function updateLiveCellsCount() {
                let count = 0;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] === 1) count++;
                    }
                }
                liveCellsElement.textContent = count;
            }
            
            // Calcular siguiente generación
            function nextGeneration() {
                // Calcular siguiente grid
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const neighbors = countNeighbors(r, c);
                        
                        if (grid[r][c] === 1) {
                            // Celda viva
                            if (neighbors < 2 || neighbors > 3) {
                                nextGrid[r][c] = 0; // Muere
                            } else {
                                nextGrid[r][c] = 1; // Sobrevive
                            }
                        } else {
                            // Celda muerta
                            if (neighbors === 3) {
                                nextGrid[r][c] = 1; // Nace
                            } else {
                                nextGrid[r][c] = 0; // Permanece muerta
                            }
                        }
                    }
                }
                
                // Actualizar grid
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        grid[r][c] = nextGrid[r][c];
                    }
                }
                
                generation++;
                generationCountElement.textContent = generation;
                updateLiveCellsCount();
                renderGrid();
                
                // Verificar si la simulación se estancó
                if (isGridStable()) {
                    pauseSimulation();
                    lifeMessage.innerHTML = `<span style="color:var(--neon-yellow)">La simulación se estabilizó en la generación ${generation}.</span>`;
                }
            }
            
            // Contar vecinos vivos
            function countNeighbors(row, col) {
                let count = 0;
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        // No contar la celda misma
                        if (dr === 0 && dc === 0) continue;
                        
                        const nr = row + dr;
                        const nc = col + dc;
                        
                        // Verificar límites (toroidal - se envuelve alrededor de los bordes)
                        const wrappedRow = (nr + rows) % rows;
                        const wrappedCol = (nc + cols) % cols;
                        
                        if (grid[wrappedRow][wrappedCol] === 1) {
                            count++;
                        }
                    }
                }
                
                return count;
            }
            
            // Verificar si el grid se estabilizó
            function isGridStable() {
                // Verificar si no hay cambios
                let changed = false;
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (grid[r][c] !== nextGrid[r][c]) {
                            changed = true;
                            break;
                        }
                    }
                    if (changed) break;
                }
                
                return !changed;
            }
            
            // Iniciar simulación
            function startSimulation() {
                if (isRunning) return;
                
                isRunning = true;
                lifeMessage.textContent = `Simulación en curso (generación ${generation})`;
                
                // Calcular intervalo basado en velocidad
                const interval = 1000 / speed;
                
                simulationInterval = setInterval(() => {
                    nextGeneration();
                }, interval);
            }
            
            // Pausar simulación
            function pauseSimulation() {
                isRunning = false;
                
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                
                lifeMessage.textContent = `Simulación pausada en la generación ${generation}.`;
            }
            
            // Un paso de simulación
            function stepSimulation() {
                if (isRunning) return;
                
                nextGeneration();
                lifeMessage.textContent = `Generación ${generation}.`;
            }
            
            // Limpiar grid
            function clearGrid() {
                pauseSimulation();
                initGame();
            }
            
            // Grid aleatorio
            function randomGrid() {
                pauseSimulation();
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        grid[r][c] = Math.random() < 0.3 ? 1 : 0;
                    }
                }
                
                generation = 0;
                generationCountElement.textContent = generation;
                updateLiveCellsCount();
                renderGrid();
                
                lifeMessage.textContent = 'Grid aleatorio generado. Haz clic en "Iniciar" para comenzar la simulación.';
            }
            
            // Cargar patrón predefinido
            function loadPattern(patternName) {
                pauseSimulation();
                initGame();
                
                // Centrar el patrón
                const centerRow = Math.floor(rows / 2);
                const centerCol = Math.floor(cols / 2);
                
                switch(patternName) {
                    case 'glider':
                        // Planeador (glider)
                        grid[centerRow][centerCol+1] = 1;
                        grid[centerRow+1][centerCol+2] = 1;
                        grid[centerRow+2][centerCol] = 1;
                        grid[centerRow+2][centerCol+1] = 1;
                        grid[centerRow+2][centerCol+2] = 1;
                        break;
                        
                    case 'blinker':
                        // Parpadeante (blinker)
                        grid[centerRow][centerCol-1] = 1;
                        grid[centerRow][centerCol] = 1;
                        grid[centerRow][centerCol+1] = 1;
                        break;
                        
                    case 'gliderGun':
                        // Pistola de planeadores (Gosper Glider Gun) - simplificada
                        const gunPattern = [
                            [5,1],[5,2],[6,1],[6,2],
                            [5,11],[6,11],[7,11],
                            [4,12],[8,12],
                            [3,13],[9,13],
                            [3,14],[9,14],
                            [6,15],
                            [4,16],[8,16],
                            [5,17],[6,17],[7,17],
                            [6,18],
                            [3,21],[4,21],[5,21],
                            [3,22],[4,22],[5,22],
                            [2,23],[6,23],
                            [1,25],[2,25],[6,25],[7,25],
                            [3,35],[4,35],[3,36],[4,36]
                        ];
                        
                        gunPattern.forEach(([r, c]) => {
                            const row = centerRow + r - 10;
                            const col = centerCol + c - 20;
                            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                                grid[row][col] = 1;
                            }
                        });
                        break;
                        
                    case 'pulsar':
                        // Pulsar
                        const pulsarPattern = [
                            [2,4],[2,5],[2,6],[2,10],[2,11],[2,12],
                            [4,2],[4,7],[4,9],[4,14],
                            [5,2],[5,7],[5,9],[5,14],
                            [6,2],[6,7],[6,9],[6,14],
                            [7,4],[7,5],[7,6],[7,10],[7,11],[7,12],
                            [9,4],[9,5],[9,6],[9,10],[9,11],[9,12],
                            [10,2],[10,7],[10,9],[10,14],
                            [11,2],[11,7],[11,9],[11,14],
                            [12,2],[12,7],[12,9],[12,14],
                            [14,4],[14,5],[14,6],[14,10],[14,11],[14,12]
                        ];
                        
                        pulsarPattern.forEach(([r, c]) => {
                            const row = centerRow + r - 8;
                            const col = centerCol + c - 8;
                            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                                grid[row][col] = 1;
                            }
                        });
                        break;
                        
                    case 'random':
                        randomGrid();
                        return;
                }
                
                renderGrid();
                updateLiveCellsCount();
                lifeMessage.textContent = `Patrón "${patternName}" cargado. Haz clic en "Iniciar" para comenzar la simulación.`;
            }
            
            // Obtener nombre de velocidad
            function getSpeedName() {
                if (speed <= 2) return 'Muy Lenta';
                if (speed <= 4) return 'Lenta';
                if (speed <= 6) return 'Media';
                if (speed <= 8) return 'Rápida';
                return 'Muy Rápida';
            }
            
            // Actualizar velocidad
            function updateSpeed() {
                speed = parseInt(speedSlider.value);
                simulationSpeedElement.textContent = getSpeedName();
                
                // Si la simulación está corriendo, reiniciar con nueva velocidad
                if (isRunning) {
                    pauseSimulation();
                    startSimulation();
                }
            }
            
            // Configurar event listeners
            document.getElementById('lifeStart').addEventListener('click', startSimulation);
            document.getElementById('lifePause').addEventListener('click', pauseSimulation);
            document.getElementById('lifeStep').addEventListener('click', stepSimulation);
            document.getElementById('lifeClear').addEventListener('click', clearGrid);
            document.getElementById('lifeRandom').addEventListener('click', randomGrid);
            
            // Patrones predefinidos
            document.querySelectorAll('#lifePatterns button').forEach(button => {
                button.addEventListener('click', () => {
                    const pattern = button.dataset.pattern;
                    loadPattern(pattern);
                });
            });
            
            // Control de velocidad
            speedSlider.addEventListener('input', updateSpeed);
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 14: Battleship ====================
        function loadBattleshipGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Battleship</h2>
                    
                    <p class="game-instructions">
                        Hunde la flota enemiga antes de que la computadora hunda la tuya. Coloca tus barcos y luego haz clic en el tablero enemigo para disparar.
                        <span style="color:var(--neon-green)">Verde</span> = barco, 
                        <span style="color:var(--neon-blue)">Azul</span> = agua, 
                        <span style="color:var(--neon-pink)">Rosa</span> = impacto.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="battleship-container">
                            <div>
                                <h3 style="color:var(--neon-green); margin-bottom:10px;">Tu Flota</h3>
                                <div class="battleship-board" id="playerBoard"></div>
                            </div>
                            <div>
                                <h3 style="color:var(--neon-pink); margin-bottom:10px;">Flota Enemiga</h3>
                                <div class="battleship-board" id="enemyBoard"></div>
                            </div>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Turno</h3>
                                <p id="currentTurn" style="font-size:1.5rem;color:var(--neon-green)">Tú</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tus Barcos</h3>
                                <p id="playerShips" style="font-size:1.5rem;color:var(--neon-blue)">5</p>
                            </div>
                            <div class="stat-box">
                                <h3>Barcos Enemigos</h3>
                                <p id="enemyShips" style="font-size:1.5rem;color:var(--neon-pink)">5</p>
                            </div>
                        </div>
                        
                        <div id="shipPlacement" style="margin:20px 0; padding:15px; background:rgba(0,255,255,0.1); border-radius:8px; border:1px solid var(--neon-blue);">
                            <h3 style="color:var(--neon-yellow); margin-bottom:10px;">Coloca tus Barcos</h3>
                            <div id="shipList" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-bottom:15px;"></div>
                            <div>
                                <button id="rotateShip" class="game-button" style="padding:8px 15px; font-size:0.9rem;">Rotar Barco (Horizontal)</button>
                                <button id="randomPlacement" class="game-button" style="padding:8px 15px; font-size:0.9rem; background:linear-gradient(45deg, #ffff00, #ffaa00); margin-left:10px;">Colocación Aleatoria</button>
                                <button id="startGame" class="game-button" style="padding:8px 15px; font-size:0.9rem; background:linear-gradient(45deg, #00ff00, #00aaff); margin-left:10px;">Comenzar Juego</button>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px; display:none;" id="gameControls">
                            <button id="battleshipNew" class="game-button">Nuevo Juego</button>
                            <button id="battleshipHint" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Pista (3)</button>
                            <button id="battleshipSurrender" class="game-button" style="background:linear-gradient(45deg, #ff0000, #ff5500)">Rendirse</button>
                        </div>
                        
                        <div class="game-feedback" id="battleshipFeedback" style="margin-top:20px;">
                            <p id="battleshipMessage">Coloca tus barcos en el tablero izquierdo. Haz clic para colocar, haz clic en "Rotar" para cambiar dirección.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initBattleshipGame();
        }

        function initBattleshipGame() {
            const boardSize = 10;
            let playerBoard = [];
            let enemyBoard = [];
            let enemyShipsBoard = []; // Tablero real de barcos enemigos
            let placingShips = true;
            let currentShip = null;
            let shipOrientation = 'horizontal'; // 'horizontal' o 'vertical'
            let playerShips = 5;
            let enemyShips = 5;
            let currentPlayer = 'player'; // 'player' o 'enemy'
            let gameActive = false;
            let hintsLeft = 3;
            
            // Barcos: [nombre, tamaño]
            const ships = [
                {name: 'Portaaviones', size: 5},
                {name: 'Acorazado', size: 4},
                {name: 'Crucero', size: 3},
                {name: 'Submarino', size: 3},
                {name: 'Destructor', size: 2}
            ];
            
            let shipsToPlace = [...ships];
            
            const playerBoardElement = document.getElementById('playerBoard');
            const enemyBoardElement = document.getElementById('enemyBoard');
            const shipListElement = document.getElementById('shipList');
            const currentTurnElement = document.getElementById('currentTurn');
            const playerShipsElement = document.getElementById('playerShips');
            const enemyShipsElement = document.getElementById('enemyShips');
            const battleshipMessage = document.getElementById('battleshipMessage');
            const shipPlacementElement = document.getElementById('shipPlacement');
            const gameControlsElement = document.getElementById('gameControls');
            
            // Inicializar juego
            function initGame() {
                // Reiniciar tableros
                playerBoard = [];
                enemyBoard = [];
                enemyShipsBoard = [];
                
                for (let r = 0; r < boardSize; r++) {
                    playerBoard[r] = [];
                    enemyBoard[r] = [];
                    enemyShipsBoard[r] = [];
                    
                    for (let c = 0; c < boardSize; c++) {
                        playerBoard[r][c] = {type: 'empty', shipIndex: -1};
                        enemyBoard[r][c] = {type: 'empty', shipIndex: -1};
                        enemyShipsBoard[r][c] = {type: 'empty', shipIndex: -1};
                    }
                }
                
                // Reiniciar estado del juego
                placingShips = true;
                currentShip = null;
                shipOrientation = 'horizontal';
                playerShips = 5;
                enemyShips = 5;
                currentPlayer = 'player';
                gameActive = false;
                hintsLeft = 3;
                shipsToPlace = [...ships];
                
                // Actualizar UI
                currentTurnElement.textContent = 'Colocando barcos';
                currentTurnElement.style.color = 'var(--neon-yellow)';
                playerShipsElement.textContent = playerShips;
                enemyShipsElement.textContent = enemyShips;
                battleshipMessage.textContent = 'Coloca tus barcos en el tablero izquierdo. Haz clic para colocar, haz clic en "Rotar" para cambiar dirección.';
                
                // Mostrar colocación de barcos, ocultar controles del juego
                shipPlacementElement.style.display = 'block';
                gameControlsElement.style.display = 'none';
                
                // Renderizar tableros
                renderBoards();
                
                // Crear lista de barcos para colocar
                createShipList();
            }
            
            // Renderizar tableros
            function renderBoards() {
                renderBoard(playerBoardElement, playerBoard, true);
                renderBoard(enemyBoardElement, enemyBoard, false);
            }
            
            // Renderizar un tablero
            function renderBoard(boardElement, board, isPlayerBoard) {
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 30px)`;
                boardElement.style.gridTemplateRows = `repeat(${boardSize}, 30px)`;
                boardElement.style.width = `${boardSize * 30}px`;
                boardElement.style.height = `${boardSize * 30}px`;
                
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'battleship-cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        const cellData = board[r][c];
                        
                        // Estilo según el tipo de celda
                        if (cellData.type === 'ship' && isPlayerBoard) {
                            cell.classList.add('ship');
                            cell.style.background = 'rgba(0, 255, 0, 0.3)';
                        } else if (cellData.type === 'hit') {
                            cell.classList.add('hit');
                            cell.style.background = 'rgba(255, 0, 0, 0.5)';
                            cell.textContent = '💥';
                        } else if (cellData.type === 'miss') {
                            cell.classList.add('miss');
                            cell.style.background = 'rgba(255, 255, 255, 0.3)';
                            cell.textContent = '💧';
                        }
                        
                        // Si estamos colocando barcos y hay un barco actual, mostrar previsualización
                        if (placingShips && isPlayerBoard && currentShip && canPlaceShip(r, c, currentShip.size, shipOrientation)) {
                            cell.style.background = 'rgba(0, 255, 255, 0.3)';
                        }
                        
                        // Event listeners
                        if (isPlayerBoard && placingShips) {
                            cell.addEventListener('click', () => placeShip(r, c));
                            cell.addEventListener('mouseenter', () => previewShip(r, c));
                            cell.addEventListener('mouseleave', () => clearPreview());
                        } else if (!isPlayerBoard && gameActive && currentPlayer === 'player' && cellData.type === 'empty') {
                            cell.addEventListener('click', () => playerShoot(r, c));
                            cell.style.cursor = 'crosshair';
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // Crear lista de barcos para colocar
            function createShipList() {
                shipListElement.innerHTML = '';
                
                shipsToPlace.forEach((ship, index) => {
                    const shipElement = document.createElement('div');
                    shipElement.style.padding = '10px';
                    shipElement.style.background = 'rgba(0, 255, 255, 0.1)';
                    shipElement.style.border = '1px solid var(--neon-blue)';
                    shipElement.style.borderRadius = '5px';
                    shipElement.style.cursor = 'pointer';
                    shipElement.textContent = `${ship.name} (${ship.size})`;
                    
                    if (currentShip && currentShip.name === ship.name) {
                        shipElement.style.background = 'rgba(0, 255, 255, 0.3)';
                        shipElement.style.borderColor = 'var(--neon-green)';
                    }
                    
                    shipElement.addEventListener('click', () => {
                        currentShip = ship;
                        createShipList();
                    });
                    
                    shipListElement.appendChild(shipElement);
                });
                
                // Seleccionar el primer barco por defecto
                if (!currentShip && shipsToPlace.length > 0) {
                    currentShip = shipsToPlace[0];
                    createShipList();
                }
            }
            
            // Verificar si se puede colocar un barco
            function canPlaceShip(row, col, size, orientation) {
                if (orientation === 'horizontal') {
                    if (col + size > boardSize) return false;
                    
                    for (let c = col; c < col + size; c++) {
                        if (playerBoard[row][c].type !== 'empty') return false;
                    }
                } else {
                    if (row + size > boardSize) return false;
                    
                    for (let r = row; r < row + size; r++) {
                        if (playerBoard[r][col].type !== 'empty') return false;
                    }
                }
                
                return true;
            }
            
            // Previsualizar colocación de barco
            function previewShip(row, col) {
                if (!currentShip || !placingShips) return;
                
                renderBoards(); // Limpiar previsualización anterior
                
                if (canPlaceShip(row, col, currentShip.size, shipOrientation)) {
                    // Resaltar celdas donde se colocaría el barco
                    const cells = playerBoardElement.querySelectorAll('.battleship-cell');
                    
                    if (shipOrientation === 'horizontal') {
                        for (let c = col; c < col + currentShip.size; c++) {
                            const cell = playerBoardElement.querySelector(`.battleship-cell[data-row="${row}"][data-col="${c}"]`);
                            if (cell) {
                                cell.style.background = 'rgba(0, 255, 255, 0.5)';
                            }
                        }
                    } else {
                        for (let r = row; r < row + currentShip.size; r++) {
                            const cell = playerBoardElement.querySelector(`.battleship-cell[data-row="${r}"][data-col="${col}"]`);
                            if (cell) {
                                cell.style.background = 'rgba(0, 255, 255, 0.5)';
                            }
                        }
                    }
                }
            }
            
            // Limpiar previsualización
            function clearPreview() {
                if (!currentShip || !placingShips) return;
                renderBoards();
            }
            
            // Colocar barco
            function placeShip(row, col) {
                if (!currentShip || !placingShips) return;
                
                if (!canPlaceShip(row, col, currentShip.size, shipOrientation)) {
                    battleshipMessage.innerHTML = `<span style="color:var(--neon-pink)">No se puede colocar el barco aquí.</span>`;
                    return;
                }
                
                // Colocar barco en el tablero
                const shipIndex = ships.length - shipsToPlace.length;
                
                if (shipOrientation === 'horizontal') {
                    for (let c = col; c < col + currentShip.size; c++) {
                        playerBoard[row][c] = {type: 'ship', shipIndex};
                    }
                } else {
                    for (let r = row; r < row + currentShip.size; r++) {
                        playerBoard[r][col] = {type: 'ship', shipIndex};
                    }
                }
                
                // Eliminar barco de la lista de barcos por colocar
                shipsToPlace = shipsToPlace.filter(ship => ship.name !== currentShip.name);
                
                // Actualizar UI
                if (shipsToPlace.length > 0) {
                    currentShip = shipsToPlace[0];
                    battleshipMessage.innerHTML = `<span style="color:var(--neon-green)">${currentShip.name} colocado. Selecciona posición para el siguiente barco.</span>`;
                } else {
                    currentShip = null;
                    battleshipMessage.textContent = 'Todos los barcos colocados. Haz clic en "Comenzar Juego".';
                }
                
                createShipList();
                renderBoards();
            }
            
            // Colocación aleatoria de barcos
            function randomPlacement() {
                if (!placingShips) return;
                
                // Reiniciar tablero del jugador
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        playerBoard[r][c] = {type: 'empty', shipIndex: -1};
                    }
                }
                
                // Colocar cada barco aleatoriamente
                ships.forEach((ship, shipIndex) => {
                    let placed = false;
                    
                    while (!placed) {
                        const orientation = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        const row = Math.floor(Math.random() * boardSize);
                        const col = Math.floor(Math.random() * boardSize);
                        
                        if (canPlaceShip(row, col, ship.size, orientation)) {
                            if (orientation === 'horizontal') {
                                for (let c = col; c < col + ship.size; c++) {
                                    playerBoard[row][c] = {type: 'ship', shipIndex};
                                }
                            } else {
                                for (let r = row; r < row + ship.size; r++) {
                                    playerBoard[r][col] = {type: 'ship', shipIndex};
                                }
                            }
                            placed = true;
                        }
                    }
                });
                
                // Actualizar UI
                shipsToPlace = [];
                currentShip = null;
                battleshipMessage.textContent = 'Barcos colocados aleatoriamente. Haz clic en "Comenzar Juego".';
                
                createShipList();
                renderBoards();
            }
            
            // Colocar barcos enemigos aleatoriamente
            function placeEnemyShips() {
                // Reiniciar tablero enemigo
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        enemyShipsBoard[r][c] = {type: 'empty', shipIndex: -1};
                    }
                }
                
                // Colocar cada barco aleatoriamente
                ships.forEach((ship, shipIndex) => {
                    let placed = false;
                    
                    while (!placed) {
                        const orientation = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                        const row = Math.floor(Math.random() * boardSize);
                        const col = Math.floor(Math.random() * boardSize);
                        
                        if (canPlaceEnemyShip(row, col, ship.size, orientation)) {
                            if (orientation === 'horizontal') {
                                for (let c = col; c < col + ship.size; c++) {
                                    enemyShipsBoard[row][c] = {type: 'ship', shipIndex};
                                }
                            } else {
                                for (let r = row; r < row + ship.size; r++) {
                                    enemyShipsBoard[r][col] = {type: 'ship', shipIndex};
                                }
                            }
                            placed = true;
                        }
                    }
                });
            }
            
            // Verificar si se puede colocar un barco enemigo
            function canPlaceEnemyShip(row, col, size, orientation) {
                if (orientation === 'horizontal') {
                    if (col + size > boardSize) return false;
                    
                    for (let c = col; c < col + size; c++) {
                        if (enemyShipsBoard[row][c].type !== 'empty') return false;
                    }
                } else {
                    if (row + size > boardSize) return false;
                    
                    for (let r = row; r < row + size; r++) {
                        if (enemyShipsBoard[r][col].type !== 'empty') return false;
                    }
                }
                
                return true;
            }
            
            // Comenzar juego
            function startGame() {
                if (shipsToPlace.length > 0) {
                    battleshipMessage.innerHTML = `<span style="color:var(--neon-pink)">Coloca todos los barcos primero.</span>`;
                    return;
                }
                
                placingShips = false;
                gameActive = true;
                
                // Colocar barcos enemigos
                placeEnemyShips();
                
                // Actualizar UI
                currentTurnElement.textContent = 'Tú';
                currentTurnElement.style.color = 'var(--neon-green)';
                battleshipMessage.textContent = '¡Juego comenzado! Tu turno. Haz clic en el tablero derecho para disparar.';
                
                // Ocultar colocación de barcos, mostrar controles del juego
                shipPlacementElement.style.display = 'none';
                gameControlsElement.style.display = 'flex';
                
                renderBoards();
            }
            
            // Disparo del jugador
            function playerShoot(row, col) {
                if (!gameActive || currentPlayer !== 'player') return;
                
                // Verificar si ya se disparó aquí
                if (enemyBoard[row][col].type !== 'empty') {
                    battleshipMessage.innerHTML = `<span style="color:var(--neon-yellow)">Ya disparaste aquí. Elige otra celda.</span>`;
                    return;
                }
                
                // Verificar si hay un barco enemigo
                if (enemyShipsBoard[row][col].type === 'ship') {
                    // ¡Impacto!
                    enemyBoard[row][col] = {type: 'hit', shipIndex: enemyShipsBoard[row][col].shipIndex};
                    
                    // Verificar si el barco fue hundido
                    const shipIndex = enemyShipsBoard[row][col].shipIndex;
                    let shipSunk = true;
                    
                    for (let r = 0; r < boardSize; r++) {
                        for (let c = 0; c < boardSize; c++) {
                            if (enemyShipsBoard[r][c].type === 'ship' && enemyShipsBoard[r][c].shipIndex === shipIndex && enemyBoard[r][c].type !== 'hit') {
                                shipSunk = false;
                                break;
                            }
                        }
                        if (!shipSunk) break;
                    }
                    
                    if (shipSunk) {
                        enemyShips--;
                        enemyShipsElement.textContent = enemyShips;
                        battleshipMessage.innerHTML = `<span style="color:var(--neon-green)">¡Impacto! ¡Hundiste un barco enemigo!</span>`;
                    } else {
                        battleshipMessage.innerHTML = `<span style="color:var(--neon-green)">¡Impacto!</span>`;
                    }
                } else {
                    // Agua
                    enemyBoard[row][col] = {type: 'miss', shipIndex: -1};
                    battleshipMessage.innerHTML = `<span style="color:var(--neon-blue)">Agua.</span>`;
                }
                
                // Verificar si el jugador ganó
                if (enemyShips === 0) {
                    endGame('player');
                    return;
                }
                
                // Cambiar turno a la computadora
                currentPlayer = 'enemy';
                currentTurnElement.textContent = 'Computadora';
                currentTurnElement.style.color = 'var(--neon-pink)';
                
                renderBoards();
                
                // La computadora dispara después de un breve retraso
                setTimeout(enemyShoot, 1000);
            }
            
            // Disparo de la computadora
            function enemyShoot() {
                if (!gameActive || currentPlayer !== 'enemy') return;
                
                // Estrategia simple de la computadora
                let row, col;
                let validShot = false;
                
                // Primero, buscar celdas adyacentes a impactos previos
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (playerBoard[r][c].type === 'hit') {
                            // Buscar celdas adyacentes no disparadas
                            const directions = [[-1,0],[1,0],[0,-1],[0,1]];
                            
                            for (const [dr, dc] of directions) {
                                const nr = r + dr;
                                const nc = c + dc;
                                
                                if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize && playerBoard[nr][nc].type === 'empty') {
                                    row = nr;
                                    col = nc;
                                    validShot = true;
                                    break;
                                }
                            }
                            
                            if (validShot) break;
                        }
                    }
                    if (validShot) break;
                }
                
                // Si no hay impactos previos adyacentes, disparar aleatoriamente
                if (!validShot) {
                    // Crear lista de celdas no disparadas
                    const availableCells = [];
                    
                    for (let r = 0; r < boardSize; r++) {
                        for (let c = 0; c < boardSize; c++) {
                            if (playerBoard[r][c].type === 'empty') {
                                availableCells.push({r, c});
                            }
                        }
                    }
                    
                    if (availableCells.length > 0) {
                        const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                        row = randomCell.r;
                        col = randomCell.c;
                        validShot = true;
                    }
                }
                
                if (validShot) {
                    // Verificar si hay un barco del jugador
                    if (playerBoard[row][col].type === 'ship') {
                        // ¡Impacto!
                        playerBoard[row][col] = {type: 'hit', shipIndex: playerBoard[row][col].shipIndex};
                        
                        // Verificar si el barco fue hundido
                        const shipIndex = playerBoard[row][col].shipIndex;
                        let shipSunk = true;
                        
                        for (let r = 0; r < boardSize; r++) {
                            for (let c = 0; c < boardSize; c++) {
                                if (playerBoard[r][c].type === 'ship' && playerBoard[r][c].shipIndex === shipIndex) {
                                    shipSunk = false;
                                    break;
                                }
                            }
                            if (!shipSunk) break;
                        }
                        
                        if (shipSunk) {
                            playerShips--;
                            playerShipsElement.textContent = playerShips;
                            battleshipMessage.innerHTML = `<span style="color:var(--neon-pink)">La computadora hundió tu ${ships[shipIndex].name}!</span>`;
                        } else {
                            battleshipMessage.innerHTML = `<span style="color:var(--neon-pink)">La computadora impactó tu barco!</span>`;
                        }
                    } else {
                        // Agua
                        playerBoard[row][col] = {type: 'miss', shipIndex: -1};
                        battleshipMessage.innerHTML = `<span style="color:var(--neon-blue)">La computadora disparó al agua.</span>`;
                    }
                    
                    // Verificar si la computadora ganó
                    if (playerShips === 0) {
                        endGame('enemy');
                        return;
                    }
                }
                
                // Cambiar turno al jugador
                currentPlayer = 'player';
                currentTurnElement.textContent = 'Tú';
                currentTurnElement.style.color = 'var(--neon-green)';
                
                renderBoards();
            }
            
            // Dar pista
            function giveHint() {
                if (!gameActive || currentPlayer !== 'player' || hintsLeft <= 0) return;
                
                // Encontrar una celda con un barco enemigo no descubierto
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (enemyShipsBoard[r][c].type === 'ship' && enemyBoard[r][c].type === 'empty') {
                            hintsLeft--;
                            battleshipMessage.innerHTML = `<span style="color:var(--neon-yellow)">Pista: Hay un barco cerca de la fila ${r+1}, columna ${c+1}.</span>`;
                            
                            // Resaltar la celda
                            const cell = enemyBoardElement.querySelector(`.battleship-cell[data-row="${r}"][data-col="${c}"]`);
                            if (cell) {
                                cell.style.boxShadow = '0 0 10px var(--neon-yellow)';
                                cell.style.animation = 'pulse 1s infinite alternate';
                                
                                // Quitar resaltado después de 3 segundos
                                setTimeout(() => {
                                    cell.style.boxShadow = '';
                                    cell.style.animation = '';
                                }, 3000);
                            }
                            
                            return;
                        }
                    }
                }
            }
            
            // Finalizar juego
            function endGame(winner) {
                gameActive = false;
                
                if (winner === 'player') {
                    battleshipMessage.innerHTML = `
                        <span style="color:var(--neon-green); font-size:1.2rem;">
                            <i class="fas fa-trophy"></i> ¡Felicidades! Hundiste toda la flota enemiga.
                        </span>
                    `;
                } else {
                    battleshipMessage.innerHTML = `
                        <span style="color:var(--neon-pink); font-size:1.2rem;">
                            <i class="fas fa-times-circle"></i> La computadora hundió toda tu flota. ¡Mejor suerte la próxima vez!
                        </span>
                    `;
                    
                    // Mostrar barcos enemigos
                    for (let r = 0; r < boardSize; r++) {
                        for (let c = 0; c < boardSize; c++) {
                            if (enemyShipsBoard[r][c].type === 'ship' && enemyBoard[r][c].type !== 'hit') {
                                enemyBoard[r][c] = {type: 'ship', shipIndex: enemyShipsBoard[r][c].shipIndex};
                            }
                        }
                    }
                    renderBoards();
                }
            }
            
            // Configurar event listeners
            document.getElementById('rotateShip').addEventListener('click', () => {
                shipOrientation = shipOrientation === 'horizontal' ? 'vertical' : 'horizontal';
                document.getElementById('rotateShip').textContent = `Rotar Barco (${shipOrientation === 'horizontal' ? 'Horizontal' : 'Vertical'})`;
                renderBoards();
            });
            
            document.getElementById('randomPlacement').addEventListener('click', randomPlacement);
            document.getElementById('startGame').addEventListener('click', startGame);
            document.getElementById('battleshipNew').addEventListener('click', initGame);
            document.getElementById('battleshipHint').addEventListener('click', giveHint);
            document.getElementById('battleshipSurrender').addEventListener('click', () => {
                if (gameActive) {
                    endGame('enemy');
                }
            });
            
            // Inicializar juego
            initGame();
        }

        // ==================== JUEGO 15: Nonogramas ====================
        function loadNonogramGame(container) {
            container.innerHTML = `
                <div class="game-container">
                    <h2 class="game-title-large">Nonogramas</h2>
                    
                    <p class="game-instructions">
                        Resuelve el rompecabezas lógico. Los números indican grupos de casillas consecutivas a rellenar.
                        Haz clic izquierdo para rellenar una casilla, clic derecho para marcar con una X.
                        <span style="color:var(--neon-green)">Verde</span> = rellenada, 
                        <span style="color:var(--neon-pink)">Rosa</span> = X.
                    </p>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <div class="nonogram-container">
                            <div id="nonogramBoard" style="display:flex;"></div>
                        </div>
                        
                        <div class="game-stats" style="margin-top:20px;">
                            <div class="stat-box">
                                <h3>Tamaño</h3>
                                <p id="nonogramSize" style="font-size:1.5rem;color:var(--neon-green)">5x5</p>
                            </div>
                            <div class="stat-box">
                                <h3>Errores</h3>
                                <p id="nonogramErrors" style="font-size:1.5rem;color:var(--neon-blue)">0</p>
                            </div>
                            <div class="stat-box">
                                <h3>Tiempo</h3>
                                <p id="nonogramTimer" style="font-size:1.5rem;color:var(--neon-pink)">00:00</p>
                            </div>
                        </div>
                        
                        <div class="game-controls" style="margin-top:20px;">
                            <button id="nonogramNew" class="game-button">Nuevo Nonograma</button>
                            <button id="nonogramCheck" class="game-button" style="background:linear-gradient(45deg, #ffff00, #ffaa00)">Comprobar</button>
                            <button id="nonogramSolve" class="game-button" style="background:linear-gradient(45deg, #00ff00, #00aaff)">Resolver</button>
                            <button id="nonogramChangeSize" class="game-button" style="background:linear-gradient(45deg, #ff00ff, #ff5500)">Cambiar Tamaño</button>
                        </div>
                        
                        <div class="game-feedback" id="nonogramFeedback" style="margin-top:20px;">
                            <p id="nonogramMessage">Haz clic izquierdo para rellenar, clic derecho para marcar con X.</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Inicializar el juego
            initNonogramGame();
        }

        function initNonogramGame() {
            let size = 5;
            let puzzle = [];
            let solution = [];
            let userGrid = [];
            let errors = 0;
            let timer = 0;
            let timerInterval = null;
            let gameActive = false;
            let solving = false;
            
            const nonogramBoard = document.getElementById('nonogramBoard');
            const nonogramSizeElement = document.getElementById('nonogramSize');
            const nonogramErrorsElement = document.getElementById('nonogramErrors');
            const nonogramTimerElement = document.getElementById('nonogramTimer');
            const nonogramMessage = document.getElementById('nonogramMessage');
            
            // Patrones de nonogramas predefinidos
            const patterns = {
                '5x5': [
                    {
                        solution: [
                            [1,1,1,0,0],
                            [1,0,0,1,0],
                            [1,1,1,0,0],
                            [1,0,0,1,0],
                            [1,0,0,1,0]
                        ],
                        name: 'Letra A'
                    },
                    {
                        solution: [
                            [1,1,1,1,0],
                            [1,0,0,0,1],
                            [1,1,1,1,0],
                            [1,0,0,0,1],
                            [1,1,1,1,0]
                        ],
                        name: 'Letra B'
                    },
                    {
                        solution: [
                            [0,1,1,1,0],
                            [1,0,0,0,1],
                            [1,0,0,0,0],
                            [1,0,0,0,1],
                            [0,1,1,1,0]
                        ],
                        name: 'Letra C'
                    }
                ],
                '8x8': [
                    {
                        solution: [
                            [0,0,1,1,1,1,0,0],
                            [0,1,0,0,0,0,1,0],
                            [1,0,1,0,0,1,0,1],
                            [1,0,0,0,0,0,0,1],
                            [1,0,1,0,0,1,0,1],
                            [1,0,0,1,1,0,0,1],
                            [0,1,0,0,0,0,1,0],
                            [0,0,1,1,1,1,0,0]
                        ],
                        name: 'Cara sonriente'
                    },
                    {
                        solution: [
                            [0,0,0,1,1,0,0,0],
                            [0,0,1,0,0,1,0,0],
                            [0,1,0,0,0,0,1,0],
                            [1,0,0,1,1,0,0,1],
                            [1,0,0,1,1,0,0,1],
                            [0,1,0,0,0,0,1,0],
                            [0,0,1,0,0,1,0,0],
                            [0,0,0,1,1,0,0,0]
                        ],
                        name: 'Flor'
                    }
                ],
                '10x10': [
                    {
                        solution: [
                            [0,0,0,0,1,1,0,0,0,0],
                            [0,0,0,1,0,0,1,0,0,0],
                            [0,0,1,0,0,0,0,1,0,0],
                            [0,1,0,0,1,1,0,0,1,0],
                            [1,0,0,1,0,0,1,0,0,1],
                            [1,0,0,1,0,0,1,0,0,1],
                            [0,1,0,0,1,1,0,0,1,0],
                            [0,0,1,0,0,0,0,1,0,0],
                            [0,0,0,1,0,0,1,0,0,0],
                            [0,0,0,0,1,1,0,0,0,0]
                        ],
                        name: 'Anillo'
                    }
                ]
            };
            
            // Inicializar juego
            function initGame() {
                // Elegir patrón aleatorio del tamaño actual
                const sizeKey = `${size}x${size}`;
                let patternList = patterns[sizeKey];
                
                if (!patternList || patternList.length === 0) {
                    // Si no hay patrón para este tamaño, generar uno aleatorio simple
                    generateRandomPuzzle();
                } else {
                    const pattern = patternList[Math.floor(Math.random() * patternList.length)];
                    solution = pattern.solution.map(row => [...row]);
                }
                
                // Crear pistas
                puzzle = generateClues(solution);
                
                // Inicializar grid del usuario
                userGrid = [];
                for (let r = 0; r < size; r++) {
                    userGrid[r] = [];
                    for (let c = 0; c < size; c++) {
                        userGrid[r][c] = 0; // 0 = vacío, 1 = rellenado, 2 = X
                    }
                }
                
                // Reiniciar estado del juego
                errors = 0;
                timer = 0;
                gameActive = true;
                solving = false;
                
                // Actualizar UI
                nonogramSizeElement.textContent = `${size}x${size}`;
                nonogramErrorsElement.textContent = errors;
                nonogramTimerElement.textContent = '00:00';
                nonogramMessage.textContent = 'Haz clic izquierdo para rellenar, clic derecho para marcar con X.';
                
                // Renderizar nonograma
                renderNonogram();
                
                // Iniciar timer
                if (timerInterval) clearInterval(timerInterval);
                startTimer();
            }
            
            // Generar pistas desde la solución
            function generateClues(grid) {
                const clues = {
                    rows: [],
                    cols: []
                };
                
                // Pistas para filas
                for (let r = 0; r < size; r++) {
                    const rowClues = [];
                    let count = 0;
                    
                    for (let c = 0; c < size; c++) {
                        if (grid[r][c] === 1) {
                            count++;
                        } else if (count > 0) {
                            rowClues.push(count);
                            count = 0;
                        }
                    }
                    
                    if (count > 0) {
                        rowClues.push(count);
                    }
                    
                    clues.rows.push(rowClues.length > 0 ? rowClues : [0]);
                }
                
                // Pistas para columnas
                for (let c = 0; c < size; c++) {
                    const colClues = [];
                    let count = 0;
                    
                    for (let r = 0; r < size; r++) {
                        if (grid[r][c] === 1) {
                            count++;
                        } else if (count > 0) {
                            colClues.push(count);
                            count = 0;
                        }
                    }
                    
                    if (count > 0) {
                        colClues.push(count);
                    }
                    
                    clues.cols.push(colClues.length > 0 ? colClues : [0]);
                }
                
                return clues;
            }
            
            // Generar puzzle aleatorio
            function generateRandomPuzzle() {
                solution = [];
                for (let r = 0; r < size; r++) {
                    solution[r] = [];
                    for (let c = 0; c < size; c++) {
                        // Probabilidad de 40% de tener una celda rellenada
                        solution[r][c] = Math.random() < 0.4 ? 1 : 0;
                    }
                }
            }
            
            // Renderizar nonograma
            function renderNonogram() {
                nonogramBoard.innerHTML = '';
                
                // Crear contenedor principal
                const container = document.createElement('div');
                container.style.display = 'grid';
                container.style.gridTemplateColumns = `auto repeat(${size}, 40px)`;
                container.style.gridTemplateRows = `auto repeat(${size}, 40px)`;
                container.style.gap = '2px';
                
                // Celda vacía en la esquina superior izquierda
                const cornerCell = document.createElement('div');
                cornerCell.style.gridColumn = '1';
                cornerCell.style.gridRow = '1';
                cornerCell.style.background = 'rgba(0, 255, 255, 0.1)';
                cornerCell.style.border = '1px solid var(--neon-blue)';
                container.appendChild(cornerCell);
                
                // Encabezados de columnas (pistas superiores)
                for (let c = 0; c < size; c++) {
                    const headerCell = document.createElement('div');
                    headerCell.style.gridColumn = c + 2;
                    headerCell.style.gridRow = 1;
                    headerCell.style.display = 'flex';
                    headerCell.style.flexDirection = 'column';
                    headerCell.style.justifyContent = 'flex-end';
                    headerCell.style.alignItems = 'center';
                    headerCell.style.padding = '2px';
                    headerCell.style.background = 'rgba(0, 255, 255, 0.1)';
                    headerCell.style.border = '1px solid var(--neon-blue)';
                    headerCell.style.fontSize = '0.8rem';
                    headerCell.style.fontWeight = 'bold';
                    headerCell.style.color = 'var(--neon-blue)';
                    
                    // Mostrar pistas de columna
                    puzzle.cols[c].forEach(clue => {
                        const clueSpan = document.createElement('span');
                        clueSpan.textContent = clue === 0 ? '' : clue;
                        headerCell.appendChild(clueSpan);
                    });
                    
                    container.appendChild(headerCell);
                }
                
                // Encabezados de filas (pistas izquierdas)
                for (let r = 0; r < size; r++) {
                    const headerCell = document.createElement('div');
                    headerCell.style.gridColumn = 1;
                    headerCell.style.gridRow = r + 2;
                    headerCell.style.display = 'flex';
                    headerCell.style.flexDirection = 'row';
                    headerCell.style.justifyContent = 'flex-end';
                    headerCell.style.alignItems = 'center';
                    headerCell.style.padding = '2px';
                    headerCell.style.background = 'rgba(0, 255, 255, 0.1)';
                    headerCell.style.border = '1px solid var(--neon-blue)';
                    headerCell.style.fontSize = '0.8rem';
                    headerCell.style.fontWeight = 'bold';
                    headerCell.style.color = 'var(--neon-blue)';
                    
                    // Mostrar pistas de fila
                    puzzle.rows[r].forEach(clue => {
                        const clueSpan = document.createElement('span');
                        clueSpan.textContent = clue === 0 ? '' : clue;
                        clueSpan.style.marginRight = '5px';
                        headerCell.appendChild(clueSpan);
                    });
                    
                    container.appendChild(headerCell);
                }
                
                // Celdas del nonograma
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'nonogram-cell';
                        cell.style.gridColumn = c + 2;
                        cell.style.gridRow = r + 2;
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        // Estado actual de la celda
                        if (userGrid[r][c] === 1) {
                            cell.classList.add('filled');
                            cell.style.background = 'var(--neon-green)';
                        } else if (userGrid[r][c] === 2) {
                            cell.classList.add('crossed');
                            cell.style.background = 'rgba(255, 0, 255, 0.3)';
                        } else {
                            cell.style.background = 'rgba(0, 0, 0, 0.3)';
                        }
                        
                        // Event listeners
                        cell.addEventListener('click', (e) => {
                            if (!gameActive || solving) return;
                            
                            if (e.button === 0) {
                                // Clic izquierdo: rellenar
                                fillCell(r, c);
                            }
                        });
                        
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            if (!gameActive || solving) return;
                            
                            // Clic derecho: marcar con X
                            markCell(r, c);
                        });
                        
                        container.appendChild(cell);
                    }
                }
                
                nonogramBoard.appendChild(container);
            }
            
            // Rellenar celda
            function fillCell(row, col) {
                if (userGrid[row][col] === 1) {
                    // Si ya está rellenada, vaciarla
                    userGrid[row][col] = 0;
                } else {
                    // Rellenar celda
                    userGrid[row][col] = 1;
                    
                    // Verificar si es correcto
                    if (solution[row][col] !== 1) {
                        errors++;
                        nonogramErrorsElement.textContent = errors;
                    }
                }
                
                renderNonogram();
                
                // Verificar si se completó
                if (checkCompletion()) {
                    endGame();
                }
            }
            
            // Marcar celda con X
            function markCell(row, col) {
                if (userGrid[row][col] === 2) {
                    // Si ya está marcada, vaciarla
                    userGrid[row][col] = 0;
                } else {
                    // Marcar celda con X
                    userGrid[row][col] = 2;
                }
                
                renderNonogram();
            }
            
            // Comprobar solución
            function checkSolution() {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (solution[r][c] === 1 && userGrid[r][c] !== 1) {
                            return false;
                        }
                        if (solution[r][c] === 0 && userGrid[r][c] === 1) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // Verificar si se completó
            function checkCompletion() {
                // Verificar que todas las celdas estén marcadas (1 o 2)
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (userGrid[r][c] === 0) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // Resolver automáticamente
            function solvePuzzle() {
                if (solving) return;
                
                solving = true;
                nonogramMessage.textContent = 'Resolviendo...';
                
                // Detener timer
                clearInterval(timerInterval);
                
                // Copiar solución al grid del usuario
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        userGrid[r][c] = solution[r][c] === 1 ? 1 : 2;
                    }
                }
                
                // Mostrar mensaje de éxito
                setTimeout(() => {
                    nonogramMessage.innerHTML = `<span style="color:var(--neon-green)">¡Nonograma resuelto!</span>`;
                    gameActive = false;
                    solving = false;
                    renderNonogram();
                }, 500);
            }
            
            // Cambiar tamaño
            function changeSize() {
                if (size === 5) {
                    size = 8;
                } else if (size === 8) {
                    size = 10;
                } else {
                    size = 5;
                }
                
                initGame();
                nonogramMessage.textContent = `Nonograma ${size}x${size} cargado. ¡Buena suerte!`;
            }
            
            // Formatear tiempo
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Iniciar timer
            function startTimer() {
                timerInterval = setInterval(() => {
                    timer++;
                    nonogramTimerElement.textContent = formatTime(timer);
                }, 1000);
            }
            
            // Finalizar juego
            function endGame() {
                // Verificar si la solución es correcta
                if (checkSolution()) {
                    gameActive = false;
                    clearInterval(timerInterval);
                    
                    nonogramMessage.innerHTML = `
                        <span style="color:var(--neon-green); font-size:1.2rem;">
                            <i class="fas fa-trophy"></i> ¡Felicidades! Resolviste el nonograma con ${errors} errores en ${formatTime(timer)}.
                        </span>
                    `;
                    
                    // Guardar récord si es mejor
                    const bestTimeKey = `nonogramBestTime_${size}`;
                    const bestErrorsKey = `nonogramBestErrors_${size}`;
                    
                    const bestTime = localStorage.getItem(bestTimeKey) || Infinity;
                    const bestErrors = localStorage.getItem(bestErrorsKey) || Infinity;
                    
                    let newRecord = false;
                    
                    if (errors < bestErrors || (errors == bestErrors && timer < bestTime)) {
                        localStorage.setItem(bestTimeKey, timer);
                        localStorage.setItem(bestErrorsKey, errors);
                        newRecord = true;
                    }
                    
                    if (newRecord) {
                        nonogramMessage.innerHTML += `
                            <p style="color:var(--neon-pink);margin-top:5px;">
                                <i class="fas fa-crown"></i> ¡Nuevo récord para nonograma ${size}x${size}!
                            </p>
                        `;
                    }
                } else {
                    nonogramMessage.innerHTML = `<span style="color:var(--neon-pink)">Completaste el nonograma, pero hay errores. ¡Revisa tu solución!</span>`;
                }
            }
            
            // Configurar event listeners
            document.getElementById('nonogramNew').addEventListener('click', initGame);
            document.getElementById('nonogramCheck').addEventListener('click', () => {
                if (!gameActive || solving) return;
                
                if (checkSolution()) {
                    nonogramMessage.innerHTML = `<span style="color:var(--neon-green)">¡Correcto! Tu solución es válida.</span>`;
                } else {
                    nonogramMessage.innerHTML = `<span style="color:var(--neon-pink)">Aún hay errores en tu solución.</span>`;
                }
            });
            document.getElementById('nonogramSolve').addEventListener('click', solvePuzzle);
            document.getElementById('nonogramChangeSize').addEventListener('click', changeSize);
            
            // Inicializar juego
            initGame();
        }

        // ==================== FUNCIONES GENERALES ====================
        // Volver al menú principal
        function returnToMain() {
            document.getElementById('mainPage').style.display = 'block';
            document.getElementById('gamePage').style.display = 'none';
            state.currentGame = null;
        }

        // Cambiar tema claro/oscuro
        function toggleTheme() {
            const root = document.documentElement;
            
            if (state.darkMode) {
                // Cambiar a modo claro
                root.style.setProperty('--dark-bg', '#f0f0ff');
                root.style.setProperty('--card-bg', 'rgba(255, 255, 255, 0.9)');
                root.style.setProperty('--text-primary', '#222244');
                root.style.setProperty('--text-secondary', '#444466');
                root.style.setProperty('--grid-color', 'rgba(0, 100, 255, 0.1)');
                state.darkMode = false;
            } else {
                // Volver a modo oscuro (original)
                root.style.setProperty('--dark-bg', '#0a0a1a');
                root.style.setProperty('--card-bg', 'rgba(16, 16, 32, 0.85)');
                root.style.setProperty('--text-primary', '#ffffff');
                root.style.setProperty('--text-secondary', '#ccccff');
                root.style.setProperty('--grid-color', 'rgba(0, 255, 255, 0.1)');
                state.darkMode = true;
            }
        }

        // Hacer returnToMain accesible globalmente para los botones en los placeholders
        window.returnToMain = returnToMain;
    </script>
</body>
</html>
